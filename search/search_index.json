{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion is a fundamental topic in mechanics that offers a clean yet rich context for understanding the application of differential equations, Newton's laws, and kinematic principles. The central goal is to investigate how the horizontal range of a projectile depends on the angle of launch. Though the setup appears straightforward, the analysis reveals intricate dependencies on initial conditions and physical parameters. Understanding projectile motion is essential in a variety of fields\u2014from sports and civil engineering to space science and military applications. By starting from first principles and layering in simulation, this project provides both theoretical insight and computational practice. 1. Theoretical Foundation: Differential Equations Assumptions: The motion is in two dimensions. Air resistance is neglected. Gravity acts uniformly downward. Launch and landing heights are equal. We begin with Newton's second law: \\(\\vec{F} = m\\vec{a} \\Rightarrow \\frac{d^2 \\vec{r}}{dt^2} = \\vec{a}\\) Decomposing motion into x (horizontal) and y (vertical) directions: Horizontal Motion: \\(\\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) t\\) Vertical Motion: \\(\\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2\\) Time of Flight: Set \\(y(t) = 0\\) to find when the projectile lands: \\(t = \\frac{2v_0 \\sin(\\theta)}{g}\\) Horizontal Range: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) This is the key result showing how range depends on initial velocity, gravity, and angle. 2. Simulation: Python Code and Visualizations Range vs. Angle Plot import numpy as np import matplotlib.pyplot as plt v0 = 30 # initial velocity in m/s g = 9.81 # gravitational acceleration in m/s^2 angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Calculate range R = (v0**2 * np.sin(2 * angles_rad)) / g # Plot range vs angle plt.figure(figsize=(10, 6)) plt.plot(angles, R, color='royalblue') plt.axvline(45, color='red', linestyle='--', label='\\u03b8 = 45\\xb0 (Max Range)') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show() Output: Visit: Colab Multiple Trajectories for Different Angles # Time vector angles_deg = [15, 30, 45, 60, 75] colors = ['blue', 'green', 'orange', 'purple', 'brown'] plt.figure(figsize=(10, 6)) for angle, color in zip(angles_deg, colors): theta = np.radians(angle) t_flight = 2 * v0 * np.sin(theta) / g t_vals = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t_vals y = v0 * np.sin(theta) * t_vals - 0.5 * g * t_vals**2 plt.plot(x, y, label=f\"{angle}\u00b0\", color=color) plt.title(\"Projectile Trajectories for Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.show() Output: Visit: Colab Animated Projectile Motion import matplotlib.animation as animation fig, ax = plt.subplots(figsize=(8, 5)) angle = np.radians(45) t_flight = 2 * v0 * np.sin(angle) / g t_vals = np.linspace(0, t_flight, 300) x_vals = v0 * np.cos(angle) * t_vals y_vals = v0 * np.sin(angle) * t_vals - 0.5 * g * t_vals**2 line, = ax.plot([], [], 'bo') ax.set_xlim(0, max(x_vals)) ax.set_ylim(0, max(y_vals)*1.1) ax.set_xlabel('Horizontal Distance (m)') ax.set_ylabel('Vertical Height (m)') ax.set_title('Animated Projectile Motion') # Initialization function def init(): line.set_data([], []) return line, # Animation function def animate(i): line.set_data(x_vals[i], y_vals[i]) return line, ani = animation.FuncAnimation(fig, animate, frames=len(t_vals), init_func=init, interval=20, blit=True) plt.show() Visit: Colab Range vs. Angle for Different Velocities velocities = [10, 20, 30, 40] plt.figure(figsize=(10, 6)) for v in velocities: R = (v**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, R, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Angle for Various Initial Velocities') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.legend() plt.grid(True) plt.show() Visit Colab Output: Curves rising in height as initial velocity increases, but always peaking at 45\u00b0. 3. Practical Applications Sports : Optimize kicking or throwing angles. Engineering : Design water fountains, civil projectiles, or robotic arm paths. Aerospace : Launch trajectories under different gravitational conditions. Defense : Missile and artillery trajectory planning. 4. Extensions and Real-World Models Air Resistance Introducing drag results in non-linear differential equations. For example: \\(m \\frac{d^2x}{dt^2} = -kv_x, \\quad m \\frac{d^2y}{dt^2} = -mg - kv_y\\) where \\(k\\) is the drag coefficient. This requires numerical solving methods (like Runge-Kutta) for simulation. Python Simulation with Air Resistance (Euler Method) def simulate_drag(v0, theta_deg, dt=0.01, k=0.1): theta = np.radians(theta_deg) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = 0, 0 positions_x, positions_y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions_x.append(x) positions_y.append(y) return positions_x, positions_y plt.figure(figsize=(10, 6)) for angle in [30, 45, 60]: x_vals, y_vals = simulate_drag(30, angle) plt.plot(x_vals, y_vals, label=f\"With drag, {angle}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.title(\"Projectile Motion with Air Resistance\") plt.legend() plt.grid(True) plt.show() Visit Colab Uneven Terrain and Variable Gravity Other extensions include: - Launching from/landing on slopes (geometry needed) - Varying \\(g\\) with altitude or planetary conditions Conclusion Starting from Newton's laws, we built a full mathematical model of projectile motion using differential equations. We derived the range formula and implemented visual simulations to understand how the angle of projection affects range. The model, while idealized, provides deep insight and serves as a powerful foundation for more complex analyses. With Python, we've created tools to simulate, visualize, and animate this system dynamically. Extensions include modeling drag and simulating on non-flat terrains\u2014perfect for bridging theory and real-world applications.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is a fundamental topic in mechanics that offers a clean yet rich context for understanding the application of differential equations, Newton's laws, and kinematic principles. The central goal is to investigate how the horizontal range of a projectile depends on the angle of launch. Though the setup appears straightforward, the analysis reveals intricate dependencies on initial conditions and physical parameters. Understanding projectile motion is essential in a variety of fields\u2014from sports and civil engineering to space science and military applications. By starting from first principles and layering in simulation, this project provides both theoretical insight and computational practice.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation-differential-equations","text":"","title":"1. Theoretical Foundation: Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#assumptions","text":"The motion is in two dimensions. Air resistance is neglected. Gravity acts uniformly downward. Launch and landing heights are equal. We begin with Newton's second law: \\(\\vec{F} = m\\vec{a} \\Rightarrow \\frac{d^2 \\vec{r}}{dt^2} = \\vec{a}\\) Decomposing motion into x (horizontal) and y (vertical) directions:","title":"Assumptions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"\\(\\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) t\\)","title":"Horizontal Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"\\(\\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2\\)","title":"Vertical Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Set \\(y(t) = 0\\) to find when the projectile lands: \\(t = \\frac{2v_0 \\sin(\\theta)}{g}\\)","title":"Time of Flight:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"\\(R = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) This is the key result showing how range depends on initial velocity, gravity, and angle.","title":"Horizontal Range:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-simulation-python-code-and-visualizations","text":"","title":"2. Simulation: Python Code and Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-plot","text":"import numpy as np import matplotlib.pyplot as plt v0 = 30 # initial velocity in m/s g = 9.81 # gravitational acceleration in m/s^2 angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Calculate range R = (v0**2 * np.sin(2 * angles_rad)) / g # Plot range vs angle plt.figure(figsize=(10, 6)) plt.plot(angles, R, color='royalblue') plt.axvline(45, color='red', linestyle='--', label='\\u03b8 = 45\\xb0 (Max Range)') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"Range vs. Angle Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output","text":"Visit: Colab","title":"Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#multiple-trajectories-for-different-angles","text":"# Time vector angles_deg = [15, 30, 45, 60, 75] colors = ['blue', 'green', 'orange', 'purple', 'brown'] plt.figure(figsize=(10, 6)) for angle, color in zip(angles_deg, colors): theta = np.radians(angle) t_flight = 2 * v0 * np.sin(theta) / g t_vals = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t_vals y = v0 * np.sin(theta) * t_vals - 0.5 * g * t_vals**2 plt.plot(x, y, label=f\"{angle}\u00b0\", color=color) plt.title(\"Projectile Trajectories for Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.show()","title":"Multiple Trajectories for Different Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output_1","text":"Visit: Colab","title":"Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#animated-projectile-motion","text":"import matplotlib.animation as animation fig, ax = plt.subplots(figsize=(8, 5)) angle = np.radians(45) t_flight = 2 * v0 * np.sin(angle) / g t_vals = np.linspace(0, t_flight, 300) x_vals = v0 * np.cos(angle) * t_vals y_vals = v0 * np.sin(angle) * t_vals - 0.5 * g * t_vals**2 line, = ax.plot([], [], 'bo') ax.set_xlim(0, max(x_vals)) ax.set_ylim(0, max(y_vals)*1.1) ax.set_xlabel('Horizontal Distance (m)') ax.set_ylabel('Vertical Height (m)') ax.set_title('Animated Projectile Motion') # Initialization function def init(): line.set_data([], []) return line, # Animation function def animate(i): line.set_data(x_vals[i], y_vals[i]) return line, ani = animation.FuncAnimation(fig, animate, frames=len(t_vals), init_func=init, interval=20, blit=True) plt.show()","title":"Animated Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visitcolab","text":"","title":"Visit:Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-for-different-velocities","text":"velocities = [10, 20, 30, 40] plt.figure(figsize=(10, 6)) for v in velocities: R = (v**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, R, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Angle for Various Initial Velocities') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.legend() plt.grid(True) plt.show() Visit Colab","title":"Range vs. Angle for Different Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output_2","text":"Curves rising in height as initial velocity increases, but always peaking at 45\u00b0.","title":"Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimize kicking or throwing angles. Engineering : Design water fountains, civil projectiles, or robotic arm paths. Aerospace : Launch trajectories under different gravitational conditions. Defense : Missile and artillery trajectory planning.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-extensions-and-real-world-models","text":"","title":"4. Extensions and Real-World Models"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#air-resistance","text":"Introducing drag results in non-linear differential equations. For example: \\(m \\frac{d^2x}{dt^2} = -kv_x, \\quad m \\frac{d^2y}{dt^2} = -mg - kv_y\\) where \\(k\\) is the drag coefficient. This requires numerical solving methods (like Runge-Kutta) for simulation.","title":"Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation-with-air-resistance-euler-method","text":"def simulate_drag(v0, theta_deg, dt=0.01, k=0.1): theta = np.radians(theta_deg) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = 0, 0 positions_x, positions_y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions_x.append(x) positions_y.append(y) return positions_x, positions_y plt.figure(figsize=(10, 6)) for angle in [30, 45, 60]: x_vals, y_vals = simulate_drag(30, angle) plt.plot(x_vals, y_vals, label=f\"With drag, {angle}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.title(\"Projectile Motion with Air Resistance\") plt.legend() plt.grid(True) plt.show() Visit Colab","title":"Python Simulation with Air Resistance (Euler Method)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#uneven-terrain-and-variable-gravity","text":"Other extensions include: - Launching from/landing on slopes (geometry needed) - Varying \\(g\\) with altitude or planetary conditions","title":"Uneven Terrain and Variable Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Starting from Newton's laws, we built a full mathematical model of projectile motion using differential equations. We derived the range formula and implemented visual simulations to understand how the angle of projection affects range. The model, while idealized, provides deep insight and serves as a powerful foundation for more complex analyses. With Python, we've created tools to simulate, visualize, and animate this system dynamically. Extensions include modeling drag and simulating on non-flat terrains\u2014perfect for bridging theory and real-world applications.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The pendulum is a powerful model in physics. From simple harmonic motion to chaos, it demonstrates how small changes \u2014 damping and forcing \u2014 result in complex behavior. This project investigates: Simple Pendulum Damped Pendulum Forced Damped Pendulum 1. Differential Equations Simple Pendulum \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = 0\\] For small angles: \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\theta = 0, \\quad \\omega_0 = \\sqrt{\\frac{g}{L}}\\] Damped Pendulum \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0\\] Forced Pendulum \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\] Where: \\(\\theta(t)\\) : angular displacement (in radians) \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) : natural frequency of the pendulum \\(A\\) : amplitude of the external driving force (torque per unit mass and length) \\(\\omega\\) : angular frequency of the driving force \\(t\\) : time \\(g\\) : gravitational acceleration \\(L\\) : length of the pendulum Forced Damped Pendulum \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\] 2. Visualizing the Simple Pendulum (Small Angle Approximation) import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 t = np.linspace(0, 10, 1000) theta = theta0 * np.cos(omega0 * t) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Simple Pendulum (Small Angle Approximation)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab 3. Visualizing the Damped Pendulum # Damped system using RK4 import numpy as np import matplotlib.pyplot as plt dt = 0.01 t = np.arange(0, 20, dt) b = 0.3 # damping theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 # Define omega0 here omega0 = 1.0 # You can change this value to the desired natural frequency def rk4_damped(theta, omega, t, dt, b, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * theta]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_damped(theta[i-1], omega[i-1], t[i-1], dt, b, omega0) plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab 4. Visualizing the Forced Pendulum import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 b = 0.0 # No damping A = 1.2 # Forcing amplitude omega_d = 2/3 # Driving frequency dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) # RK4 integration for the forced pendulum def rk4_step(theta, omega, t, dt): def f(t, y): theta, omega = y dtheta = omega domega = -omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 # Simulation theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = theta0 omega[0] = omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt) # Plotting fig, axs = plt.subplots(1, 2, figsize=(12, 4)) # Time Series axs[0].plot(t, theta, color='darkorange') axs[0].set_title(\"Forced Pendulum (No Damping) - Time Series\") axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(\"Angle \u03b8 (rad)\") axs[0].grid(True) # Phase Portrait axs[1].plot(theta, omega, color='orangered') axs[1].set_title(\"Forced Pendulum (No Damping) - Phase Portrait\") axs[1].set_xlabel(\"\u03b8 (rad)\") axs[1].set_ylabel(\"\u03c9 (rad/s)\") axs[1].grid(True) plt.tight_layout() plt.show() Visit: Colab 5. Visualizing the Forced Damped Pendulum # Forced Damped Pendulum Simulation import numpy as np import matplotlib.pyplot as plt # Parameters omega0 = 2 dt = 0.01 t = np.arange(0, 10, dt) A = 1.2 omega_d = 2/3 b = 0.5 theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 def rk4_forced(theta, omega, t, dt, b, A, omega_d, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t)]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_forced(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, omega0) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab 6. Animation of the Forced Damped Pendulum import matplotlib.animation as animation from IPython.display import HTML import numpy as np # This was missing # Assuming L represents the length of the pendulum, set it to a reasonable value L = 1 # You can adjust this value as needed x_vals = L * np.sin(theta) y_vals = -L * np.cos(theta) fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2, 1.2) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.grid() line, = ax.plot([], [], 'o-', lw=2) trail, = ax.plot([], [], '-', lw=0.5) xdata, ydata = [], [] def init(): line.set_data([], []) trail.set_data([], []) return line, trail def animate(i): x, y = x_vals[i], y_vals[i] xdata.append(x) ydata.append(y) if len(xdata) > 100: xdata.pop(0) ydata.pop(0) line.set_data([0, x], [0, y]) trail.set_data(xdata, ydata) return line, trail ani = animation.FuncAnimation(fig, animate, frames=range(0, len(x_vals), 5), init_func=init, blit=True, interval=20) plt.close() HTML(ani.to_jshtml()) Visit: Colab import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 dt = 0.01 t_max = 20 t = np.arange(0, t_max, dt) # Unified RK4 method def rk4_step(theta, omega, t, dt, b=0, A=0, omega_d=0, use_sin=True): def f(t, y): theta, omega = y dtheta = omega if use_sin: domega = -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) else: domega = -b * omega - omega0**2 * theta + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 def simulate(b=0, A=0, omega_d=0, use_sin=True): theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0], omega[0] = theta0, omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, use_sin) return theta, omega # Simulate all three theta1, omega1 = simulate(b=0, A=0, use_sin=False) # Simple theta2, omega2 = simulate(b=0.2, A=0, use_sin=False) # Damped theta3, omega3 = simulate(b=0.5, A=1.2, omega_d=2/3, use_sin=True) # Forced # Plot layout fig, axs = plt.subplots(3, 2, figsize=(12, 10)) titles = [\"1) Simple Pendulum\", \"2) Damped Pendulum\", \"3) Forced Pendulum\"] colors = ['red', 'blue', 'teal'] # Time Series axs[0, 0].plot(t, theta1, color=colors[0]) axs[1, 0].plot(t, theta2, color=colors[1]) axs[2, 0].plot(t, theta3, color=colors[2]) for i in range(3): axs[i, 0].set_title(\"Time Series\") axs[i, 0].set_xlabel(\"Time (s)\") axs[i, 0].set_ylabel(\"\u03b8 (rad)\") axs[i, 0].grid(True) axs[i, 0].annotate(titles[i], xy=(0.95, 0.85), xycoords='axes fraction', ha='right', fontsize=11, color=colors[i], weight='bold') # Phase Portraits axs[0, 1].plot(theta1, omega1, color=colors[0]) axs[1, 1].plot(theta2, omega2, color=colors[1]) axs[2, 1].plot(theta3, omega3, color=colors[2]) for i in range(3): axs[i, 1].set_title(\"Phase Portrait\") axs[i, 1].set_xlabel(\"\u03b8 (rad)\") axs[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axs[i, 1].grid(True) plt.tight_layout() plt.show() Visit: Colab 7. Extensions and Advanced Explorations Phase Portraits & Poincar\u00e9 Sections : Reveal geometry of motion and transitions to chaos. Bifurcation Diagrams : Vary forcing amplitude \\(A\\) or frequency \\(\\omega\\) and plot long-term values. Energy Analysis : Study how energy is gained/lost under forcing and damping. Lyapunov Exponents : Quantify sensitivity to initial conditions (chaos). Double Pendulum : A 2-link pendulum introduces deeper chaos with no external force. Planetary Gravity : Modify \\(g\\) to simulate behavior on Mars, Moon, etc. 8. Conclusion This project comprehensively examined pendulum dynamics in three stages: Variant Damping Forcing Behavior Simple Pendulum \u2718 \u2718 Periodic Damped Pendulum \u2714 \u2718 Decaying oscillations Forced Damped \u2714 \u2714 Periodic / Quasiperiodic / Chaotic We: - Derived differential equations - Simulated each case using Runge-Kutta - Visualized the systems with graphs and animations - Proposed extensions into bifurcations, chaos, and energy studies The forced damped pendulum, though conceptually simple, becomes a gateway into the study of nonlinear systems and chaos \u2014 illustrating how deterministic rules can yield unpredictable motion.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The pendulum is a powerful model in physics. From simple harmonic motion to chaos, it demonstrates how small changes \u2014 damping and forcing \u2014 result in complex behavior. This project investigates: Simple Pendulum Damped Pendulum Forced Damped Pendulum","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-differential-equations","text":"","title":"1. Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simple-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = 0\\] For small angles: \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\theta = 0, \\quad \\omega_0 = \\sqrt{\\frac{g}{L}}\\]","title":"Simple Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damped-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0\\]","title":"Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\] Where: \\(\\theta(t)\\) : angular displacement (in radians) \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) : natural frequency of the pendulum \\(A\\) : amplitude of the external driving force (torque per unit mass and length) \\(\\omega\\) : angular frequency of the driving force \\(t\\) : time \\(g\\) : gravitational acceleration \\(L\\) : length of the pendulum","title":"Forced Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\]","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-visualizing-the-simple-pendulum-small-angle-approximation","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 t = np.linspace(0, 10, 1000) theta = theta0 * np.cos(omega0 * t) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Simple Pendulum (Small Angle Approximation)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab","title":"2. Visualizing the Simple Pendulum (Small Angle Approximation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-visualizing-the-damped-pendulum","text":"# Damped system using RK4 import numpy as np import matplotlib.pyplot as plt dt = 0.01 t = np.arange(0, 20, dt) b = 0.3 # damping theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 # Define omega0 here omega0 = 1.0 # You can change this value to the desired natural frequency def rk4_damped(theta, omega, t, dt, b, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * theta]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_damped(theta[i-1], omega[i-1], t[i-1], dt, b, omega0) plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab","title":"3. Visualizing the Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-visualizing-the-forced-pendulum","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 b = 0.0 # No damping A = 1.2 # Forcing amplitude omega_d = 2/3 # Driving frequency dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) # RK4 integration for the forced pendulum def rk4_step(theta, omega, t, dt): def f(t, y): theta, omega = y dtheta = omega domega = -omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 # Simulation theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = theta0 omega[0] = omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt) # Plotting fig, axs = plt.subplots(1, 2, figsize=(12, 4)) # Time Series axs[0].plot(t, theta, color='darkorange') axs[0].set_title(\"Forced Pendulum (No Damping) - Time Series\") axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(\"Angle \u03b8 (rad)\") axs[0].grid(True) # Phase Portrait axs[1].plot(theta, omega, color='orangered') axs[1].set_title(\"Forced Pendulum (No Damping) - Phase Portrait\") axs[1].set_xlabel(\"\u03b8 (rad)\") axs[1].set_ylabel(\"\u03c9 (rad/s)\") axs[1].grid(True) plt.tight_layout() plt.show() Visit: Colab","title":"4. Visualizing the Forced Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-visualizing-the-forced-damped-pendulum","text":"# Forced Damped Pendulum Simulation import numpy as np import matplotlib.pyplot as plt # Parameters omega0 = 2 dt = 0.01 t = np.arange(0, 10, dt) A = 1.2 omega_d = 2/3 b = 0.5 theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 def rk4_forced(theta, omega, t, dt, b, A, omega_d, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t)]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_forced(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, omega0) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab","title":"5. Visualizing the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-animation-of-the-forced-damped-pendulum","text":"import matplotlib.animation as animation from IPython.display import HTML import numpy as np # This was missing # Assuming L represents the length of the pendulum, set it to a reasonable value L = 1 # You can adjust this value as needed x_vals = L * np.sin(theta) y_vals = -L * np.cos(theta) fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2, 1.2) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.grid() line, = ax.plot([], [], 'o-', lw=2) trail, = ax.plot([], [], '-', lw=0.5) xdata, ydata = [], [] def init(): line.set_data([], []) trail.set_data([], []) return line, trail def animate(i): x, y = x_vals[i], y_vals[i] xdata.append(x) ydata.append(y) if len(xdata) > 100: xdata.pop(0) ydata.pop(0) line.set_data([0, x], [0, y]) trail.set_data(xdata, ydata) return line, trail ani = animation.FuncAnimation(fig, animate, frames=range(0, len(x_vals), 5), init_func=init, blit=True, interval=20) plt.close() HTML(ani.to_jshtml())","title":"6. Animation of the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visit-colab","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 dt = 0.01 t_max = 20 t = np.arange(0, t_max, dt) # Unified RK4 method def rk4_step(theta, omega, t, dt, b=0, A=0, omega_d=0, use_sin=True): def f(t, y): theta, omega = y dtheta = omega if use_sin: domega = -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) else: domega = -b * omega - omega0**2 * theta + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 def simulate(b=0, A=0, omega_d=0, use_sin=True): theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0], omega[0] = theta0, omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, use_sin) return theta, omega # Simulate all three theta1, omega1 = simulate(b=0, A=0, use_sin=False) # Simple theta2, omega2 = simulate(b=0.2, A=0, use_sin=False) # Damped theta3, omega3 = simulate(b=0.5, A=1.2, omega_d=2/3, use_sin=True) # Forced # Plot layout fig, axs = plt.subplots(3, 2, figsize=(12, 10)) titles = [\"1) Simple Pendulum\", \"2) Damped Pendulum\", \"3) Forced Pendulum\"] colors = ['red', 'blue', 'teal'] # Time Series axs[0, 0].plot(t, theta1, color=colors[0]) axs[1, 0].plot(t, theta2, color=colors[1]) axs[2, 0].plot(t, theta3, color=colors[2]) for i in range(3): axs[i, 0].set_title(\"Time Series\") axs[i, 0].set_xlabel(\"Time (s)\") axs[i, 0].set_ylabel(\"\u03b8 (rad)\") axs[i, 0].grid(True) axs[i, 0].annotate(titles[i], xy=(0.95, 0.85), xycoords='axes fraction', ha='right', fontsize=11, color=colors[i], weight='bold') # Phase Portraits axs[0, 1].plot(theta1, omega1, color=colors[0]) axs[1, 1].plot(theta2, omega2, color=colors[1]) axs[2, 1].plot(theta3, omega3, color=colors[2]) for i in range(3): axs[i, 1].set_title(\"Phase Portrait\") axs[i, 1].set_xlabel(\"\u03b8 (rad)\") axs[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axs[i, 1].grid(True) plt.tight_layout() plt.show() Visit: Colab","title":"Visit: Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-extensions-and-advanced-explorations","text":"Phase Portraits & Poincar\u00e9 Sections : Reveal geometry of motion and transitions to chaos. Bifurcation Diagrams : Vary forcing amplitude \\(A\\) or frequency \\(\\omega\\) and plot long-term values. Energy Analysis : Study how energy is gained/lost under forcing and damping. Lyapunov Exponents : Quantify sensitivity to initial conditions (chaos). Double Pendulum : A 2-link pendulum introduces deeper chaos with no external force. Planetary Gravity : Modify \\(g\\) to simulate behavior on Mars, Moon, etc.","title":"7. Extensions and Advanced Explorations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#8-conclusion","text":"This project comprehensively examined pendulum dynamics in three stages: Variant Damping Forcing Behavior Simple Pendulum \u2718 \u2718 Periodic Damped Pendulum \u2714 \u2718 Decaying oscillations Forced Damped \u2714 \u2714 Periodic / Quasiperiodic / Chaotic We: - Derived differential equations - Simulated each case using Runge-Kutta - Visualized the systems with graphs and animations - Proposed extensions into bifurcations, chaos, and energy studies The forced damped pendulum, though conceptually simple, becomes a gateway into the study of nonlinear systems and chaos \u2014 illustrating how deterministic rules can yield unpredictable motion.","title":"8. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The elegant relationship between the square of the orbital period (T) and the cube of the orbital radius (r) for circular orbits, known as Kepler\u2019s Third Law , reveals deep insights into gravitational interactions. This project aims to derive this law starting from Newtonian mechanics and differential equations, explore its real-world implications, and validate it through simulations and animations. Kepler\u2019s Third Law reveals a fundamental relationship in orbital mechanics: \\[T^2 \\propto r^3\\] This law connects the period of revolution \\(T\\) of a planet (or satellite) with the radius \\(r\\) of its circular orbit. It's a powerful tool used in celestial mechanics, satellite design, and calculating masses of celestial bodies. Theoretical Derivation using Newtonian Mechanics Step 1: Gravitational Force Newton\u2019s Law of Gravitation \\[F_g = \\frac{G M m}{r^2}\\] Step 2: Centripetal Force for Circular Orbits \\[F_c = \\frac{m v^2}{r}\\] Step 3: Equating Forces \\[\\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\] Step 4: Express Orbital Period \\[T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2}\\] Substitute \\(v^2\\) : \\[T^2 = \\frac{4\\pi^2 r^2}{\\frac{G M}{r}} = \\frac{4\\pi^2 r^3}{G M}\\] Final Form: \\[T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\Rightarrow T^2 \\propto r^3\\] Theoretical Analysis via Differential Equations Newton\u2019s Law of Universal Gravitation Gravitational force between two bodies of mass \\(M\\) (e.g., Earth) and \\(m\\) (e.g., satellite) is: \\[F = \\frac{G M m}{r^2}\\] Circular Motion Requirement For an object to stay in circular orbit, this gravitational force must equal the centripetal force: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\] Derivation Using Differential Equations The radial acceleration for a mass \\(m\\) in circular motion is: \\[\\vec{a} = \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M}{r^2} \\hat{r}\\] If the motion is constrained to a circular orbit, the position vector is: \\[\\vec{r}(t) = r (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j})\\] Differentiating twice gives: \\[\\frac{d^2 \\vec{r}}{dt^2} = -r \\omega^2 (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j}) = -\\omega^2 \\vec{r}\\] From Newton\u2019s second law: \\[m \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M m}{r^2} \\hat{r} \\Rightarrow -m \\omega^2 \\vec{r} = -\\frac{G M m}{r^2} \\hat{r}\\] Solving: \\[\\omega^2 = \\frac{G M}{r^3} \\Rightarrow T^2 = \\left( \\frac{2\\pi}{\\omega} \\right)^2 = \\frac{4\\pi^2 r^3}{G M}\\] This is Kepler\u2019s Third Law for circular orbits. Real-World Examples Moon's Orbit Around Earth Radius: \\(r \\approx 3.84 \\times 10^8\\) m Period: \\(T \\approx 27.3\\) days Verify Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\) Planets in the Solar System Planet Orbital Radius (AU) Period (years) Mercury 0.39 0.24 Earth 1.00 1.00 Jupiter 5.20 11.86 \\[\\frac{T^2}{r^3} \\approx \\text{constant}\\] import matplotlib.pyplot as plt import numpy as np # Sample data (replace with your actual data) radius = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.54]) # AU period = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Calculate T^2 and R^3 T_squared = period**2 R_cubed = radius**3 # Create the plot plt.figure(figsize=(8, 6)) plt.scatter(R_cubed, T_squared, label='Data Points') # Create the scatter plot # Add a best fit line (linear regression) coefficients = np.polyfit(R_cubed, T_squared, 1) polynomial = np.poly1d(coefficients) R_cubed_fit = np.linspace(min(R_cubed), max(R_cubed), 100) plt.plot(R_cubed_fit, polynomial(R_cubed_fit), color='red', label='Best Fit Line') # Add labels and title plt.xlabel(r'$R^3$ (AU$^3$)') plt.ylabel(r'$T^2$ (years$^2$)') plt.title('Orbital Period vs. Radius (Kepler\\'s Third Law)') plt.grid(True) # Add grid for better readability plt.legend() # Calculate and print the slope slope = coefficients[0] print(f\"Slope of the best-fit line: {slope:.2f}\") # Add text annotation showing the slope on the plot. plt.annotate(f\"Slope: {slope:.2f}\", xy=(0.65 * max(R_cubed), 0.85 * max(T_squared)), fontsize=12) # Show the plot plt.show() Visit: Colab Verifying Kepler\u2019s Law !pip install ace_tools # Install the required 'ace_tools' module import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns # Orbital data for planets (radius in AU, period in years) planets = { \"Mercury\": {\"r_AU\": 0.39, \"T_years\": 0.240846}, \"Venus\": {\"r_AU\": 0.723, \"T_years\": 0.615}, \"Earth\": {\"r_AU\": 1.000, \"T_years\": 1.000}, \"Mars\": {\"r_AU\": 1.524, \"T_years\": 1.881} } # Convert to arrays names = list(planets.keys()) r_AU = np.array([planets[p][\"r_AU\"] for p in names]) T_years = np.array([planets[p][\"T_years\"] for p in names]) # Calculate T^2 and r^3 T_squared = T_years**2 r_cubed = r_AU**3 # Create a DataFrame for visualization df = pd.DataFrame({ \"Planet\": names, \"r (AU)\": r_AU, \"T (years)\": T_years, \"r^3 (AU^3)\": r_cubed, \"T^2 (years^2)\": T_squared }) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 6)) sns.scatterplot(x=r_cubed, y=T_squared, hue=names, s=100) plt.plot(r_cubed, T_squared, 'k--', alpha=0.6) # Line for visual confirmation plt.xlabel(\"r\u00b3 (AU\u00b3)\") plt.ylabel(\"T\u00b2 (years\u00b2)\") plt.title(\"Verification of Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True) plt.legend(title=\"Planet\") plt.tight_layout() plt.show() import ace_tools as tools; tools.display_dataframe_to_user(name=\"Planetary Orbital Data\", dataframe=df) Visit: Colab Planetary Orbital Data (AU & Years) Planet Orbital Radius \\( r \\) (AU) Orbital Period \\( T \\) (years) \\( r^3 \\) (AU\u00b3) \\( T^2 \\) (years\u00b2) Mercury 0.390 0.240846 0.059319 0.058007 Venus 0.723 0.615 0.377933 0.378225 Earth 1.000 1.000 1.000000 1.000000 Mars 1.524 1.881 3.539606 3.538161 Animation of a Circular Orbit import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of the Earth (kg) r = 3.84e8 # Radius of the orbit (Moon-Earth distance, m) omega = np.sqrt(G * M / r**3) # Angular velocity (rad/s) # Time settings T = 2 * np.pi / omega # Orbital period (s) t_vals = np.linspace(0, T, 500) # Time points # Orbital coordinates x_vals = r * np.cos(omega * t_vals) y_vals = r * np.sin(omega * t_vals) # Plot setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2*r, 1.2*r) ax.set_ylim(-1.2*r, 1.2*r) ax.set_aspect('equal') ax.set_title('Circular Orbit') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') # Static Earth ax.plot(0, 0, 'yo', markersize=12, label='Earth') # Satellite dot and path satellite, = ax.plot([], [], 'ro', label='Satellite') path, = ax.plot([], [], 'r--', alpha=0.5) def init(): satellite.set_data([], []) path.set_data([], []) return satellite, path def update(frame): # Ensure x and y are lists or 1-dimensional arrays x = [x_vals[frame]] # or x = np.array([x_vals[frame]]) y = [y_vals[frame]] # or y = np.array([y_vals[frame]]) satellite.set_data(x, y) path.set_data(x_vals[:frame+1], y_vals[:frame+1]) return satellite, path ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True, interval=20) # Display in Jupyter/Colab HTML(ani.to_jshtml()) Visit: Colab Extensions to Elliptical Orbits Kepler\u2019s Third Law generalizes to elliptical orbits: \\[T^2 \\propto a^3\\] Where \\(a\\) is the semi-major axis . This law still holds but requires integration over elliptical motion, using: Vis-viva equation: \\(v^2 = G M \\left( \\frac{2}{r} - \\frac{1}{a} \\right)\\) Orbital energy methods Numerical integration for eccentric orbits Astronomical Implications Calculate planetary masses Estimate satellite altitudes Study exoplanet orbits Design satellite constellations (e.g., Starlink) Measure black hole masses via stellar motion Aspect Description Law \\(T^2 \\propto r^3\\) for circular orbits Derived From Newton\u2019s Law + differential equations Verification Simulations, plots of \\(T^2\\) vs \\(r^3\\) Used For Planetary systems, satellites, exoplanets Animation Visualized stable orbit with Python Kepler\u2019s Law Applied to the Solar System Planets: Mercury, Venus, Earth, Mars Planet Orbital Radius (10\u2078 km) Period (days) Mercury 57.9 87.97 Venus 108.2 224.70 Earth 149.6 365.25 Mars 227.9 687.00 Calculating Mass of Earth (Using the Moon) \\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) G = 6.67430e-11 r_earth_moon = 3.844e8 T_moon = 27.32 * 86400 M_earth = 4 * np.pi**2 * r_earth_moon**3 / (G * T_moon**2) print(f\"Mass of Earth \u2248 {M_earth:.2e} kg\") Output: \\(5.97 \\times 10^{24} \\, \\text{kg}\\) (correct) Calculating Mass of the Sun (Using Earth's Orbit) \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) \\(T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) r_earth_sun = 1.496e11 T_earth = 365.25 * 86400 M_sun = 4 * np.pi**2 * r_earth_sun**3 / (G * T_earth**2) print(f\"Mass of Sun \u2248 {M_sun:.2e} kg\") Output: \\(1.99 \\times 10^{30} \\, \\text{kg}\\) (correct) Orbit Animation from matplotlib.animation import FuncAnimation from IPython.display import HTML # Time setup t_vals = np.linspace(0, 2 * np.pi, 500) x_vals = r_earth_sun * np.cos(t_vals) y_vals = r_earth_sun * np.sin(t_vals) fig, ax = plt.subplots(figsize=(6,6)) ax.set_xlim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_ylim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') earth, = ax.plot([], [], 'ro') sun = ax.plot(0, 0, 'yo', markersize=12) def init(): earth.set_data([], []) return earth, def update(i): earth.set_data(x_vals[i], y_vals[i]) return earth, ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True) HTML(ani.to_jshtml()) Visit: Colab Concept Value Kepler's Law \\(T^2 \\propto r^3\\) Derived from Newton's Gravity + Centripetal Motion T\u00b2 vs r\u00b3 Plot Straight line confirmed Mass of Earth \\(\\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) Mass of Sun \\(\\approx 1.99 \\times 10^{30} \\, \\text{kg}\\) Planets Used Mercury, Venus, Earth, Mars Python All steps simulated and visualized","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The elegant relationship between the square of the orbital period (T) and the cube of the orbital radius (r) for circular orbits, known as Kepler\u2019s Third Law , reveals deep insights into gravitational interactions. This project aims to derive this law starting from Newtonian mechanics and differential equations, explore its real-world implications, and validate it through simulations and animations. Kepler\u2019s Third Law reveals a fundamental relationship in orbital mechanics: \\[T^2 \\propto r^3\\] This law connects the period of revolution \\(T\\) of a planet (or satellite) with the radius \\(r\\) of its circular orbit. It's a powerful tool used in celestial mechanics, satellite design, and calculating masses of celestial bodies.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-derivation-using-newtonian-mechanics","text":"","title":"Theoretical Derivation using Newtonian Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-gravitational-force","text":"Newton\u2019s Law of Gravitation \\[F_g = \\frac{G M m}{r^2}\\]","title":"Step 1: Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-centripetal-force-for-circular-orbits","text":"\\[F_c = \\frac{m v^2}{r}\\]","title":"Step 2: Centripetal Force for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-3-equating-forces","text":"\\[\\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\]","title":"Step 3: Equating Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-4-express-orbital-period","text":"\\[T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2}\\] Substitute \\(v^2\\) : \\[T^2 = \\frac{4\\pi^2 r^2}{\\frac{G M}{r}} = \\frac{4\\pi^2 r^3}{G M}\\] Final Form: \\[T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\Rightarrow T^2 \\propto r^3\\]","title":"Step 4: Express Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-analysis-via-differential-equations","text":"","title":"Theoretical Analysis via Differential Equations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-universal-gravitation","text":"Gravitational force between two bodies of mass \\(M\\) (e.g., Earth) and \\(m\\) (e.g., satellite) is: \\[F = \\frac{G M m}{r^2}\\]","title":"Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#circular-motion-requirement","text":"For an object to stay in circular orbit, this gravitational force must equal the centripetal force: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\]","title":"Circular Motion Requirement"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-using-differential-equations","text":"The radial acceleration for a mass \\(m\\) in circular motion is: \\[\\vec{a} = \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M}{r^2} \\hat{r}\\] If the motion is constrained to a circular orbit, the position vector is: \\[\\vec{r}(t) = r (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j})\\] Differentiating twice gives: \\[\\frac{d^2 \\vec{r}}{dt^2} = -r \\omega^2 (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j}) = -\\omega^2 \\vec{r}\\] From Newton\u2019s second law: \\[m \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M m}{r^2} \\hat{r} \\Rightarrow -m \\omega^2 \\vec{r} = -\\frac{G M m}{r^2} \\hat{r}\\] Solving: \\[\\omega^2 = \\frac{G M}{r^3} \\Rightarrow T^2 = \\left( \\frac{2\\pi}{\\omega} \\right)^2 = \\frac{4\\pi^2 r^3}{G M}\\] This is Kepler\u2019s Third Law for circular orbits.","title":"Derivation Using Differential Equations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#moons-orbit-around-earth","text":"Radius: \\(r \\approx 3.84 \\times 10^8\\) m Period: \\(T \\approx 27.3\\) days Verify Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\)","title":"Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-in-the-solar-system","text":"Planet Orbital Radius (AU) Period (years) Mercury 0.39 0.24 Earth 1.00 1.00 Jupiter 5.20 11.86 \\[\\frac{T^2}{r^3} \\approx \\text{constant}\\] import matplotlib.pyplot as plt import numpy as np # Sample data (replace with your actual data) radius = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.54]) # AU period = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Calculate T^2 and R^3 T_squared = period**2 R_cubed = radius**3 # Create the plot plt.figure(figsize=(8, 6)) plt.scatter(R_cubed, T_squared, label='Data Points') # Create the scatter plot # Add a best fit line (linear regression) coefficients = np.polyfit(R_cubed, T_squared, 1) polynomial = np.poly1d(coefficients) R_cubed_fit = np.linspace(min(R_cubed), max(R_cubed), 100) plt.plot(R_cubed_fit, polynomial(R_cubed_fit), color='red', label='Best Fit Line') # Add labels and title plt.xlabel(r'$R^3$ (AU$^3$)') plt.ylabel(r'$T^2$ (years$^2$)') plt.title('Orbital Period vs. Radius (Kepler\\'s Third Law)') plt.grid(True) # Add grid for better readability plt.legend() # Calculate and print the slope slope = coefficients[0] print(f\"Slope of the best-fit line: {slope:.2f}\") # Add text annotation showing the slope on the plot. plt.annotate(f\"Slope: {slope:.2f}\", xy=(0.65 * max(R_cubed), 0.85 * max(T_squared)), fontsize=12) # Show the plot plt.show() Visit: Colab","title":"Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#verifying-keplers-law","text":"!pip install ace_tools # Install the required 'ace_tools' module import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns # Orbital data for planets (radius in AU, period in years) planets = { \"Mercury\": {\"r_AU\": 0.39, \"T_years\": 0.240846}, \"Venus\": {\"r_AU\": 0.723, \"T_years\": 0.615}, \"Earth\": {\"r_AU\": 1.000, \"T_years\": 1.000}, \"Mars\": {\"r_AU\": 1.524, \"T_years\": 1.881} } # Convert to arrays names = list(planets.keys()) r_AU = np.array([planets[p][\"r_AU\"] for p in names]) T_years = np.array([planets[p][\"T_years\"] for p in names]) # Calculate T^2 and r^3 T_squared = T_years**2 r_cubed = r_AU**3 # Create a DataFrame for visualization df = pd.DataFrame({ \"Planet\": names, \"r (AU)\": r_AU, \"T (years)\": T_years, \"r^3 (AU^3)\": r_cubed, \"T^2 (years^2)\": T_squared }) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 6)) sns.scatterplot(x=r_cubed, y=T_squared, hue=names, s=100) plt.plot(r_cubed, T_squared, 'k--', alpha=0.6) # Line for visual confirmation plt.xlabel(\"r\u00b3 (AU\u00b3)\") plt.ylabel(\"T\u00b2 (years\u00b2)\") plt.title(\"Verification of Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True) plt.legend(title=\"Planet\") plt.tight_layout() plt.show() import ace_tools as tools; tools.display_dataframe_to_user(name=\"Planetary Orbital Data\", dataframe=df) Visit: Colab","title":"Verifying Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planetary-orbital-data-au-years","text":"Planet Orbital Radius \\( r \\) (AU) Orbital Period \\( T \\) (years) \\( r^3 \\) (AU\u00b3) \\( T^2 \\) (years\u00b2) Mercury 0.390 0.240846 0.059319 0.058007 Venus 0.723 0.615 0.377933 0.378225 Earth 1.000 1.000 1.000000 1.000000 Mars 1.524 1.881 3.539606 3.538161","title":"Planetary Orbital Data (AU &amp; Years)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#animation-of-a-circular-orbit","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of the Earth (kg) r = 3.84e8 # Radius of the orbit (Moon-Earth distance, m) omega = np.sqrt(G * M / r**3) # Angular velocity (rad/s) # Time settings T = 2 * np.pi / omega # Orbital period (s) t_vals = np.linspace(0, T, 500) # Time points # Orbital coordinates x_vals = r * np.cos(omega * t_vals) y_vals = r * np.sin(omega * t_vals) # Plot setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2*r, 1.2*r) ax.set_ylim(-1.2*r, 1.2*r) ax.set_aspect('equal') ax.set_title('Circular Orbit') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') # Static Earth ax.plot(0, 0, 'yo', markersize=12, label='Earth') # Satellite dot and path satellite, = ax.plot([], [], 'ro', label='Satellite') path, = ax.plot([], [], 'r--', alpha=0.5) def init(): satellite.set_data([], []) path.set_data([], []) return satellite, path def update(frame): # Ensure x and y are lists or 1-dimensional arrays x = [x_vals[frame]] # or x = np.array([x_vals[frame]]) y = [y_vals[frame]] # or y = np.array([y_vals[frame]]) satellite.set_data(x, y) path.set_data(x_vals[:frame+1], y_vals[:frame+1]) return satellite, path ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True, interval=20) # Display in Jupyter/Colab HTML(ani.to_jshtml())","title":"Animation of a Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visitcolab","text":"","title":"Visit:Colab"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extensions-to-elliptical-orbits","text":"Kepler\u2019s Third Law generalizes to elliptical orbits: \\[T^2 \\propto a^3\\] Where \\(a\\) is the semi-major axis . This law still holds but requires integration over elliptical motion, using: Vis-viva equation: \\(v^2 = G M \\left( \\frac{2}{r} - \\frac{1}{a} \\right)\\) Orbital energy methods Numerical integration for eccentric orbits","title":"Extensions to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-implications","text":"Calculate planetary masses Estimate satellite altitudes Study exoplanet orbits Design satellite constellations (e.g., Starlink) Measure black hole masses via stellar motion Aspect Description Law \\(T^2 \\propto r^3\\) for circular orbits Derived From Newton\u2019s Law + differential equations Verification Simulations, plots of \\(T^2\\) vs \\(r^3\\) Used For Planetary systems, satellites, exoplanets Animation Visualized stable orbit with Python","title":"Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-law-applied-to-the-solar-system","text":"","title":"Kepler\u2019s Law Applied to the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-mercury-venus-earth-mars","text":"Planet Orbital Radius (10\u2078 km) Period (days) Mercury 57.9 87.97 Venus 108.2 224.70 Earth 149.6 365.25 Mars 227.9 687.00","title":"Planets: Mercury, Venus, Earth, Mars"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-mass-of-earth-using-the-moon","text":"\\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) G = 6.67430e-11 r_earth_moon = 3.844e8 T_moon = 27.32 * 86400 M_earth = 4 * np.pi**2 * r_earth_moon**3 / (G * T_moon**2) print(f\"Mass of Earth \u2248 {M_earth:.2e} kg\") Output: \\(5.97 \\times 10^{24} \\, \\text{kg}\\) (correct)","title":"Calculating Mass of Earth (Using the Moon)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-mass-of-the-sun-using-earths-orbit","text":"\\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) \\(T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) r_earth_sun = 1.496e11 T_earth = 365.25 * 86400 M_sun = 4 * np.pi**2 * r_earth_sun**3 / (G * T_earth**2) print(f\"Mass of Sun \u2248 {M_sun:.2e} kg\") Output: \\(1.99 \\times 10^{30} \\, \\text{kg}\\) (correct)","title":"Calculating Mass of the Sun (Using Earth's Orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbit-animation","text":"from matplotlib.animation import FuncAnimation from IPython.display import HTML # Time setup t_vals = np.linspace(0, 2 * np.pi, 500) x_vals = r_earth_sun * np.cos(t_vals) y_vals = r_earth_sun * np.sin(t_vals) fig, ax = plt.subplots(figsize=(6,6)) ax.set_xlim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_ylim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') earth, = ax.plot([], [], 'ro') sun = ax.plot(0, 0, 'yo', markersize=12) def init(): earth.set_data([], []) return earth, def update(i): earth.set_data(x_vals[i], y_vals[i]) return earth, ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True) HTML(ani.to_jshtml()) Visit: Colab Concept Value Kepler's Law \\(T^2 \\propto r^3\\) Derived from Newton's Gravity + Centripetal Motion T\u00b2 vs r\u00b3 Plot Straight line confirmed Mass of Earth \\(\\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) Mass of Sun \\(\\approx 1.99 \\times 10^{30} \\, \\text{kg}\\) Planets Used Mercury, Venus, Earth, Mars Python All steps simulated and visualized","title":"Orbit Animation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Introduction In celestial mechanics and spaceflight engineering, understanding the conditions required to move between gravitational domains is essential. From launching satellites into Earth orbit to sending interstellar probes like Voyager , space missions must overcome gravitational boundaries defined by the cosmic velocities . These velocities represent thresholds in orbital mechanics, each marking a different kind of escape: First Cosmic Velocity : Required to enter stable circular orbit. Second Cosmic Velocity : Required to completely escape a planet\u2019s gravity. Third Cosmic Velocity : Required to escape both a planet\u2019s and its star's gravity, reaching interstellar space. 2. Theoretical Foundation 2.1 First Cosmic Velocity \u2013 Orbital Velocity Concept : The speed to stay in low circular orbit, counteracting gravity with centripetal acceleration. Derivation : \\( \\(F_{\\text{gravity}} = \\frac{GMm}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{mv^2}{r}\\) \\) Equating the two: \\( \\(\\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{r}}\\) \\) Intuition : Go too slow, you fall back. Go too fast, you escape. 2.2 Second Cosmic Velocity \u2013 Escape Velocity Concept : Minimum speed to reach infinity with zero kinetic energy remaining. Energy Approach : \\( \\(E = K + U = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\geq 0 \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{r}}\\) \\) Notice : \\(v_2 = \\sqrt{2} \\cdot v_1\\) . It takes ~41% more speed than orbiting to escape. 2.3 Third Cosmic Velocity \u2013 Solar System Escape Concept : Speed to escape both the planet and the Sun from the planet\u2019s orbit. \\[v_3 = \\sqrt{v_2^2 + v_{\\text{orbit,Sun}}^2} = \\sqrt{2 \\frac{GM_p}{r} + \\frac{GM_\\odot}{R_{\\text{orbit}}}}\\] Where: - \\(M_\\odot\\) : mass of the Sun. - \\(R_{\\text{orbit}}\\) : orbital radius of the planet. Key Point : You\u2019re fighting two gravity wells : the planet and the star. 3. Simulation & Code 3.1 Python Code: Velocity Calculations & Visualization import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_sun = 1.989e30 # [Mass (kg), Radius (m), Orbital Radius from Sun (m)] bodies = { \"Earth\": [5.972e24, 6.371e6, 1.496e11], \"Moon\": [7.342e22, 1.737e6, 1.5e11 + 3.844e8], \"Mars\": [6.417e23, 3.389e6, 2.279e11], \"Jupiter\": [1.898e27, 6.9911e7, 7.785e11] } def v1(M, R): return np.sqrt(G * M / R) def v2(M, R): return np.sqrt(2 * G * M / R) def v3(M, R, R_orbit): return np.sqrt(v2(M, R)**2 + (G * M_sun / R_orbit)) v1s, v2s, v3s, names = [], [], [], [] for name, (M, R, R_orbit) in bodies.items(): names.append(name) v1s.append(v1(M, R)) v2s.append(v2(M, R)) v3s.append(v3(M, R, R_orbit)) # Plot x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(10, 6)) plt.bar(x - width, np.array(v1s)/1000, width, label='1st Cosmic Velocity') plt.bar(x, np.array(v2s)/1000, width, label='2nd Cosmic Velocity') plt.bar(x + width, np.array(v3s)/1000, width, label='3rd Cosmic Velocity') plt.xticks(x, names) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities of Celestial Bodies\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visit: Colab 3.2 Numerical Results Table Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) Mass Ratio (to Earth) Earth 7.91 11.19 ~42.1 1.00 Moon 1.68 2.38 ~41.4 0.012 Mars 3.56 5.03 ~40.3 0.107 Jupiter 42.1 59.5 ~75.4 317.8 3.3 Escape Velocity vs. Planetary Radius and Mass import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # Ranges of radius and mass radii = np.linspace(1e6, 1e8, 100) # from 1,000 km to 100,000 km masses = [1e22, 1e24, 1e26, 1e28] # various planet masses plt.figure(figsize=(10, 6)) for M in masses: v_esc = np.sqrt(2 * G * M / radii) plt.plot(radii / 1e6, v_esc / 1e3, label=f'M = {M:.0e} kg') plt.xlabel('Radius (10\u2076 m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs. Radius for Different Masses') plt.legend() plt.grid(True) plt.tight_layout() plt.show() Visit: Colab 3.4 Cosmic Velocity Ratios (v2/v1 and v3/v2) # Calculate ratios v1_arr = np.array(v1s) v2_arr = np.array(v2s) v3_arr = np.array(v3s) ratios_21 = v2_arr / v1_arr ratios_32 = v3_arr / v2_arr x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(10, 5)) plt.bar(x - width/2, ratios_21, width, label='v\u2082 / v\u2081') plt.bar(x + width/2, ratios_32, width, label='v\u2083 / v\u2082') plt.xticks(x, names) plt.ylabel(\"Velocity Ratio\") plt.title(\"Cosmic Velocity Ratios Across Celestial Bodies\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visit: Colab 3.5 3D-Like Plot of Velocities vs Mass and Radius from mpl_toolkits.mplot3d import Axes3D # Meshgrid of radii and masses r_vals = np.linspace(1e6, 1e8, 100) m_vals = np.linspace(1e22, 1e28, 100) R, M = np.meshgrid(r_vals, m_vals) V_escape = np.sqrt(2 * G * M / R) fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(R/1e6, M/1e24, V_escape/1e3, cmap='viridis') ax.set_xlabel('Radius (10\u2076 m)') ax.set_ylabel('Mass (10\u00b2\u2074 kg)') ax.set_zlabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity vs. Mass and Radius') plt.tight_layout() plt.show() Visit: Colab 3.6 Animated Escape Velocity vs. Radius for Increasing Mass # First, import animation tools import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 radii = np.linspace(1e6, 1e8, 300) # Radii from 1000 km to 100,000 km # Mass range (frame-wise) mass_vals = np.linspace(1e22, 1e28, 100) # From small asteroid to gas giant fig, ax = plt.subplots(figsize=(8, 6)) line, = ax.plot([], [], lw=2) text = ax.text(0.05, 0.9, '', transform=ax.transAxes) ax.set_xlim(radii[0]/1e6, radii[-1]/1e6) ax.set_ylim(0, 100) ax.set_xlabel('Radius (10\u2076 m)') ax.set_ylabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity vs Radius for Varying Mass') ax.grid() def init(): line.set_data([], []) text.set_text('') return line, text def update(frame): M = mass_vals[frame] v_esc = np.sqrt(2 * G * M / radii) / 1000 # Convert to km/s line.set_data(radii / 1e6, v_esc) text.set_text(f'Mass = {M:.1e} kg') return line, text ani = FuncAnimation(fig, update, frames=len(mass_vals), init_func=init, blit=True) plt.close() HTML(ani.to_jshtml()) Visit: Colab 4. Engineering and Mission Design Use Cases by Velocity Cosmic Velocity Use Case 1st Satellite launch (LEO, MEO) 2nd Planetary missions (Mars, Moon) 3rd Interstellar travel (Voyager, Pioneer) Design Considerations Fuel Efficiency : Most fuel is spent reaching low orbit. Timing and gravity assists help achieve 2nd/3rd velocities. Gravity Assists : Used by Voyager , Cassini , and New Horizons to incrementally achieve solar system escape. 5. Future Exploration and Cosmic Challenges Voyager 1 is the only human object beyond the heliopause (~17 km/s). Interstellar Missions like Breakthrough Starshot aim to reach 0.1c using laser propulsion. Cosmic Horizons : Interstellar escape velocities will eventually require non-chemical propulsion\u2014solar sails, nuclear, or antimatter-based tech. 6. Conclusion Cosmic velocities define the very boundary between planetary, interplanetary, and interstellar travel. These are not abstract ideas but the core calculations used to plan every space mission. From basic orbits to escaping the solar system, this knowledge: Guides launch protocols. Optimizes fuel usage. Enables human dreams of interstellar travel. Space exploration begins not with a rocket launch, but with understanding these fundamental speeds.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction","text":"In celestial mechanics and spaceflight engineering, understanding the conditions required to move between gravitational domains is essential. From launching satellites into Earth orbit to sending interstellar probes like Voyager , space missions must overcome gravitational boundaries defined by the cosmic velocities . These velocities represent thresholds in orbital mechanics, each marking a different kind of escape: First Cosmic Velocity : Required to enter stable circular orbit. Second Cosmic Velocity : Required to completely escape a planet\u2019s gravity. Third Cosmic Velocity : Required to escape both a planet\u2019s and its star's gravity, reaching interstellar space.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-first-cosmic-velocity-orbital-velocity","text":"Concept : The speed to stay in low circular orbit, counteracting gravity with centripetal acceleration. Derivation : \\( \\(F_{\\text{gravity}} = \\frac{GMm}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{mv^2}{r}\\) \\) Equating the two: \\( \\(\\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{r}}\\) \\) Intuition : Go too slow, you fall back. Go too fast, you escape.","title":"2.1 First Cosmic Velocity \u2013 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-second-cosmic-velocity-escape-velocity","text":"Concept : Minimum speed to reach infinity with zero kinetic energy remaining. Energy Approach : \\( \\(E = K + U = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\geq 0 \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{r}}\\) \\) Notice : \\(v_2 = \\sqrt{2} \\cdot v_1\\) . It takes ~41% more speed than orbiting to escape.","title":"2.2 Second Cosmic Velocity \u2013 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity-solar-system-escape","text":"Concept : Speed to escape both the planet and the Sun from the planet\u2019s orbit. \\[v_3 = \\sqrt{v_2^2 + v_{\\text{orbit,Sun}}^2} = \\sqrt{2 \\frac{GM_p}{r} + \\frac{GM_\\odot}{R_{\\text{orbit}}}}\\] Where: - \\(M_\\odot\\) : mass of the Sun. - \\(R_{\\text{orbit}}\\) : orbital radius of the planet. Key Point : You\u2019re fighting two gravity wells : the planet and the star.","title":"2.3 Third Cosmic Velocity \u2013 Solar System Escape"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-simulation-code","text":"","title":"3. Simulation &amp; Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-python-code-velocity-calculations-visualization","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_sun = 1.989e30 # [Mass (kg), Radius (m), Orbital Radius from Sun (m)] bodies = { \"Earth\": [5.972e24, 6.371e6, 1.496e11], \"Moon\": [7.342e22, 1.737e6, 1.5e11 + 3.844e8], \"Mars\": [6.417e23, 3.389e6, 2.279e11], \"Jupiter\": [1.898e27, 6.9911e7, 7.785e11] } def v1(M, R): return np.sqrt(G * M / R) def v2(M, R): return np.sqrt(2 * G * M / R) def v3(M, R, R_orbit): return np.sqrt(v2(M, R)**2 + (G * M_sun / R_orbit)) v1s, v2s, v3s, names = [], [], [], [] for name, (M, R, R_orbit) in bodies.items(): names.append(name) v1s.append(v1(M, R)) v2s.append(v2(M, R)) v3s.append(v3(M, R, R_orbit)) # Plot x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(10, 6)) plt.bar(x - width, np.array(v1s)/1000, width, label='1st Cosmic Velocity') plt.bar(x, np.array(v2s)/1000, width, label='2nd Cosmic Velocity') plt.bar(x + width, np.array(v3s)/1000, width, label='3rd Cosmic Velocity') plt.xticks(x, names) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities of Celestial Bodies\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visit: Colab","title":"3.1 Python Code: Velocity Calculations &amp; Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-numerical-results-table","text":"Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) Mass Ratio (to Earth) Earth 7.91 11.19 ~42.1 1.00 Moon 1.68 2.38 ~41.4 0.012 Mars 3.56 5.03 ~40.3 0.107 Jupiter 42.1 59.5 ~75.4 317.8","title":"3.2 Numerical Results Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#33-escape-velocity-vs-planetary-radius-and-mass","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # Ranges of radius and mass radii = np.linspace(1e6, 1e8, 100) # from 1,000 km to 100,000 km masses = [1e22, 1e24, 1e26, 1e28] # various planet masses plt.figure(figsize=(10, 6)) for M in masses: v_esc = np.sqrt(2 * G * M / radii) plt.plot(radii / 1e6, v_esc / 1e3, label=f'M = {M:.0e} kg') plt.xlabel('Radius (10\u2076 m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs. Radius for Different Masses') plt.legend() plt.grid(True) plt.tight_layout() plt.show() Visit: Colab","title":"3.3 Escape Velocity vs. Planetary Radius and Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#34-cosmic-velocity-ratios-v2v1-and-v3v2","text":"# Calculate ratios v1_arr = np.array(v1s) v2_arr = np.array(v2s) v3_arr = np.array(v3s) ratios_21 = v2_arr / v1_arr ratios_32 = v3_arr / v2_arr x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(10, 5)) plt.bar(x - width/2, ratios_21, width, label='v\u2082 / v\u2081') plt.bar(x + width/2, ratios_32, width, label='v\u2083 / v\u2082') plt.xticks(x, names) plt.ylabel(\"Velocity Ratio\") plt.title(\"Cosmic Velocity Ratios Across Celestial Bodies\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visit: Colab","title":"3.4 Cosmic Velocity Ratios (v2/v1 and v3/v2)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#35-3d-like-plot-of-velocities-vs-mass-and-radius","text":"from mpl_toolkits.mplot3d import Axes3D # Meshgrid of radii and masses r_vals = np.linspace(1e6, 1e8, 100) m_vals = np.linspace(1e22, 1e28, 100) R, M = np.meshgrid(r_vals, m_vals) V_escape = np.sqrt(2 * G * M / R) fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(R/1e6, M/1e24, V_escape/1e3, cmap='viridis') ax.set_xlabel('Radius (10\u2076 m)') ax.set_ylabel('Mass (10\u00b2\u2074 kg)') ax.set_zlabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity vs. Mass and Radius') plt.tight_layout() plt.show() Visit: Colab","title":"3.5 3D-Like Plot of Velocities vs Mass and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_2/#36-animated-escape-velocity-vs-radius-for-increasing-mass","text":"# First, import animation tools import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 radii = np.linspace(1e6, 1e8, 300) # Radii from 1000 km to 100,000 km # Mass range (frame-wise) mass_vals = np.linspace(1e22, 1e28, 100) # From small asteroid to gas giant fig, ax = plt.subplots(figsize=(8, 6)) line, = ax.plot([], [], lw=2) text = ax.text(0.05, 0.9, '', transform=ax.transAxes) ax.set_xlim(radii[0]/1e6, radii[-1]/1e6) ax.set_ylim(0, 100) ax.set_xlabel('Radius (10\u2076 m)') ax.set_ylabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity vs Radius for Varying Mass') ax.grid() def init(): line.set_data([], []) text.set_text('') return line, text def update(frame): M = mass_vals[frame] v_esc = np.sqrt(2 * G * M / radii) / 1000 # Convert to km/s line.set_data(radii / 1e6, v_esc) text.set_text(f'Mass = {M:.1e} kg') return line, text ani = FuncAnimation(fig, update, frames=len(mass_vals), init_func=init, blit=True) plt.close() HTML(ani.to_jshtml()) Visit: Colab","title":"3.6 Animated Escape Velocity vs. Radius for Increasing Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-engineering-and-mission-design","text":"","title":"4. Engineering and Mission Design"},{"location":"1%20Physics/2%20Gravity/Problem_2/#use-cases-by-velocity","text":"Cosmic Velocity Use Case 1st Satellite launch (LEO, MEO) 2nd Planetary missions (Mars, Moon) 3rd Interstellar travel (Voyager, Pioneer)","title":"Use Cases by Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#design-considerations","text":"Fuel Efficiency : Most fuel is spent reaching low orbit. Timing and gravity assists help achieve 2nd/3rd velocities. Gravity Assists : Used by Voyager , Cassini , and New Horizons to incrementally achieve solar system escape.","title":"Design Considerations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-future-exploration-and-cosmic-challenges","text":"Voyager 1 is the only human object beyond the heliopause (~17 km/s). Interstellar Missions like Breakthrough Starshot aim to reach 0.1c using laser propulsion. Cosmic Horizons : Interstellar escape velocities will eventually require non-chemical propulsion\u2014solar sails, nuclear, or antimatter-based tech.","title":"5. Future Exploration and Cosmic Challenges"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-conclusion","text":"Cosmic velocities define the very boundary between planetary, interplanetary, and interstellar travel. These are not abstract ideas but the core calculations used to plan every space mission. From basic orbits to escaping the solar system, this knowledge: Guides launch protocols. Optimizes fuel usage. Enables human dreams of interstellar travel. Space exploration begins not with a rocket launch, but with understanding these fundamental speeds.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Introduction This project analyzes the trajectories of a freely released payload near Earth, focusing on gravitational forces and initial conditions (velocity, altitude). The goal is to simulate and visualize possible trajectories (elliptical, parabolic, hyperbolic) using Python in Google Colab. The main challenge is to understand how different initial velocities (ranging from 5 km/s to 13 km/s) influence whether the payload stays in orbit, reenters, or escapes Earth's gravity. 2. Theoretical Background 2.1 Governing Equations The gravitational force between Earth and the payload is given by: \\[ F = \\frac{GMm}{r^2} \\] Where: \\(G\\) = Gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) \\(M\\) = Mass of the Earth (5.972 \u00d7 10\u00b2\u2074 kg) \\(m\\) = Mass of the payload \\(r\\) = Distance from Earth's center to the payload 2.2 Equations of Motion: The acceleration acting on the payload is: \\[ a = \\frac{GM}{r^2} \\] The second-order differential equation governing the motion is: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM}{r^2} \\hat{r} \\] 3. Simulation Code plt.figure(figsize=(8, 8)) plt.plot(trajectory[:, 0], trajectory[:, 1], label=\"Payload Trajectory\") earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5, label='Earth') plt.gca().add_patch(earth) plt.gca().set_aspect('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Trajectory of Released Payload Near Earth') plt.legend() plt.grid(True) plt.show() Visit: Colab 4. Animation Code fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-2*R_earth, 2*R_earth) ax.set_ylim(-2*R_earth, 2*R_earth) ax.set_aspect('equal') ax.set_title(\"Payload Trajectory Animation\") earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5) payload, = ax.plot([], [], 'ro', markersize=4) path, = ax.plot([], [], 'r-', linewidth=1) ax.add_patch(earth) def init(): payload.set_data([], []) path.set_data([], []) return payload, path def update(frame): payload.set_data([trajectory[frame, 0]], [trajectory[frame, 1]]) # Fix: Pass sequences path.set_data(trajectory[:frame+1, 0], trajectory[:frame+1, 1]) return payload, path ani = FuncAnimation(fig, update, frames=len(trajectory), init_func=init, blit=True, interval=30) HTML(ani.to_jshtml()) Visit: Colab fig, ax = plt.subplots(figsize=(10, 10)) # Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.4, label='Earth') ax.add_patch(earth) # Trajectories for (v_kms, traj), color in zip(trajectories, colors): if traj.shape[0] > 0: ax.plot(traj[:, 0], traj[:, 1], color=color, label=f\"{v_kms:.1f} km/s\") # Initial position marker ax.plot(r0[0], r0[1], 'ro', label=\"Launch Point\") # Formatting ax.set_title(\"Trajectories from 800 km Altitude for Various Velocities\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_aspect('equal') ax.set_xlim(-2*R_earth, 2*R_earth) ax.set_ylim(-2*R_earth, 2*R_earth) ax.grid(True) ax.legend(loc='upper right') plt.show() Visit: Colab 5. Discussion Orbital and Escape Dynamics: Velocities below 7.9 km/s result in elliptical orbits. Velocities around 11.2 km/s result in parabolic trajectories (escape). Velocities above 11.2 km/s show hyperbolic escape trajectories. Real-World Applications: Satellite launches: Achieving stable orbits with minimum energy. Reentry planning: Calculating safe descent paths. Space missions: Determining escape velocities for interplanetary travel. 6. Conclusion By simulating trajectories with varying initial velocities, we demonstrate the critical role of initial speed in determining whether the payload remains bound to Earth or escapes into space. The graphical and animated representations provide a clear visualization of these dynamics.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction","text":"This project analyzes the trajectories of a freely released payload near Earth, focusing on gravitational forces and initial conditions (velocity, altitude). The goal is to simulate and visualize possible trajectories (elliptical, parabolic, hyperbolic) using Python in Google Colab. The main challenge is to understand how different initial velocities (ranging from 5 km/s to 13 km/s) influence whether the payload stays in orbit, reenters, or escapes Earth's gravity.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-theoretical-background","text":"","title":"2. Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#21-governing-equations","text":"The gravitational force between Earth and the payload is given by: \\[ F = \\frac{GMm}{r^2} \\] Where: \\(G\\) = Gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) \\(M\\) = Mass of the Earth (5.972 \u00d7 10\u00b2\u2074 kg) \\(m\\) = Mass of the payload \\(r\\) = Distance from Earth's center to the payload","title":"2.1 Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#22-equations-of-motion","text":"The acceleration acting on the payload is: \\[ a = \\frac{GM}{r^2} \\] The second-order differential equation governing the motion is: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM}{r^2} \\hat{r} \\]","title":"2.2 Equations of Motion:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-simulation-code","text":"plt.figure(figsize=(8, 8)) plt.plot(trajectory[:, 0], trajectory[:, 1], label=\"Payload Trajectory\") earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5, label='Earth') plt.gca().add_patch(earth) plt.gca().set_aspect('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Trajectory of Released Payload Near Earth') plt.legend() plt.grid(True) plt.show() Visit: Colab","title":"3. Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-animation-code","text":"fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-2*R_earth, 2*R_earth) ax.set_ylim(-2*R_earth, 2*R_earth) ax.set_aspect('equal') ax.set_title(\"Payload Trajectory Animation\") earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5) payload, = ax.plot([], [], 'ro', markersize=4) path, = ax.plot([], [], 'r-', linewidth=1) ax.add_patch(earth) def init(): payload.set_data([], []) path.set_data([], []) return payload, path def update(frame): payload.set_data([trajectory[frame, 0]], [trajectory[frame, 1]]) # Fix: Pass sequences path.set_data(trajectory[:frame+1, 0], trajectory[:frame+1, 1]) return payload, path ani = FuncAnimation(fig, update, frames=len(trajectory), init_func=init, blit=True, interval=30) HTML(ani.to_jshtml()) Visit: Colab fig, ax = plt.subplots(figsize=(10, 10)) # Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.4, label='Earth') ax.add_patch(earth) # Trajectories for (v_kms, traj), color in zip(trajectories, colors): if traj.shape[0] > 0: ax.plot(traj[:, 0], traj[:, 1], color=color, label=f\"{v_kms:.1f} km/s\") # Initial position marker ax.plot(r0[0], r0[1], 'ro', label=\"Launch Point\") # Formatting ax.set_title(\"Trajectories from 800 km Altitude for Various Velocities\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_aspect('equal') ax.set_xlim(-2*R_earth, 2*R_earth) ax.set_ylim(-2*R_earth, 2*R_earth) ax.grid(True) ax.legend(loc='upper right') plt.show() Visit: Colab","title":"4. Animation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-discussion","text":"Orbital and Escape Dynamics: Velocities below 7.9 km/s result in elliptical orbits. Velocities around 11.2 km/s result in parabolic trajectories (escape). Velocities above 11.2 km/s show hyperbolic escape trajectories. Real-World Applications: Satellite launches: Achieving stable orbits with minimum energy. Reentry planning: Calculating safe descent paths. Space missions: Determining escape velocities for interplanetary travel.","title":"5. Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-conclusion","text":"By simulating trajectories with varying initial velocities, we demonstrate the critical role of initial speed in determining whether the payload remains bound to Earth or escapes into space. The graphical and animated representations provide a clear visualization of these dynamics.","title":"6. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Wave interference explains how multiple wave sources interact. Water waves from different points (like stones dropped into a pond) create constructive (amplifying) and destructive (canceling) interference patterns. By simulating these with point sources at the vertices of polygons, we visually understand the superposition principle in 2D wave systems. Wave Theory Wave Equation for a Single Source: A circular wave from a point \\((x_0, y_0)\\) is modeled as: \\[ z(x, y, t) = A \\cdot \\sin(kr - \\omega t + \\phi) \\] Where: \\(A\\) : Amplitude \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source \\(k = \\frac{2\\pi}{\\lambda}\\) : Wavenumber \\(\\omega = 2\\pi f\\) : Angular frequency \\(\\phi\\) : Initial phase Superposition for \\(N\\) Sources: \\[ Z(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\sin(k r_i - \\omega t + \\phi_i) \\] 1. Single Source Simulation # Parameters A = 1.0 # amplitude \u03bb = 2.0 # wavelength f = 1.0 # frequency \u03c9 = 2 * np.pi * f k = 2 * np.pi / \u03bb phi = 0 # Grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Source source = (0, 0) # Distance from source R = np.sqrt((X - source[0])**2 + (Y - source[1])**2) # Wave function def wave_frame(t): return A * np.sin(k * R - \u03c9 * t + phi) # Static heatmap plt.figure(figsize=(6, 6)) plt.imshow(wave_frame(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') plt.title('Single Source - Heatmap') plt.colorbar(label='Amplitude') plt.show() Visit: Colab Animation: fig, ax = plt.subplots(figsize=(6, 6)) im = ax.imshow(wave_frame(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') ax.set_title('Single Source Wave Animation') def animate(t): im.set_array(wave_frame(t)) return [im] ani = animation.FuncAnimation(fig, animate, frames=np.linspace(0, 2, 60), interval=100, blit=True) HTML(ani.to_jshtml()) Visit: Colab 2. Two Sources Interference sources = [(-3, 0), (3, 0)] def interference_frame(t): total = np.zeros_like(X) for sx, sy in sources: R = np.sqrt((X - sx)**2 + (Y - sy)**2) total += A * np.sin(k * R - \u03c9 * t) return total # Static Interference Heatmap plt.figure(figsize=(6, 6)) plt.imshow(interference_frame(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') plt.title('Two Sources - Heatmap') plt.colorbar(label='Amplitude') plt.show() Visit: Colab Animation: fig, ax = plt.subplots(figsize=(6, 6)) im = ax.imshow(interference_frame(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') ax.set_title('Two Source Interference Animation') def animate(t): im.set_array(interference_frame(t)) return [im] ani = animation.FuncAnimation(fig, animate, frames=np.linspace(0, 2, 60), interval=100, blit=True) HTML(ani.to_jshtml()) Visit: Colab 3. Polygon Sources (Triangle, Square, Pentagon) def generate_polygon_sources(n, radius=5): return [(radius * np.cos(2 * np.pi * i / n), radius * np.sin(2 * np.pi * i / n)) for i in range(n)] # Choose n = 3, 4, 5 for triangle, square, pentagon sources = generate_polygon_sources(n=5) def polygon_wave(t): total = np.zeros_like(X) for sx, sy in sources: R = np.sqrt((X - sx)**2 + (Y - sy)**2) total += A * np.sin(k * R - \u03c9 * t) return total # Static plt.figure(figsize=(6, 6)) plt.imshow(polygon_wave(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') plt.title('Interference from Pentagon Vertices') plt.colorbar(label='Amplitude') plt.show() Visit: Colab Polygon Animation: fig, ax = plt.subplots(figsize=(6, 6)) im = ax.imshow(polygon_wave(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') ax.set_title('Polygon Source Interference Animation') def animate(t): im.set_array(polygon_wave(t)) return [im] ani = animation.FuncAnimation(fig, animate, frames=np.linspace(0, 2, 60), interval=100, blit=True) HTML(ani.to_jshtml()) Visit: Colab 3D Visualization from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') Z = polygon_wave(0) ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(\"3D Interference from Polygon\") ax.set_zlim(-2, 2) plt.show() Visit: Colab Summary Case Sources Description 1 Single Basic circular wave 2 Two Shows constructive/destructive lines 3 Triangle/Square/Pentagon Complex interference lattices","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Wave interference explains how multiple wave sources interact. Water waves from different points (like stones dropped into a pond) create constructive (amplifying) and destructive (canceling) interference patterns. By simulating these with point sources at the vertices of polygons, we visually understand the superposition principle in 2D wave systems.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-theory","text":"","title":"Wave Theory"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation-for-a-single-source","text":"A circular wave from a point \\((x_0, y_0)\\) is modeled as: \\[ z(x, y, t) = A \\cdot \\sin(kr - \\omega t + \\phi) \\] Where: \\(A\\) : Amplitude \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source \\(k = \\frac{2\\pi}{\\lambda}\\) : Wavenumber \\(\\omega = 2\\pi f\\) : Angular frequency \\(\\phi\\) : Initial phase","title":"Wave Equation for a Single Source:"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-for-n-sources","text":"\\[ Z(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\sin(k r_i - \\omega t + \\phi_i) \\]","title":"Superposition for \\(N\\) Sources:"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-single-source-simulation","text":"# Parameters A = 1.0 # amplitude \u03bb = 2.0 # wavelength f = 1.0 # frequency \u03c9 = 2 * np.pi * f k = 2 * np.pi / \u03bb phi = 0 # Grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Source source = (0, 0) # Distance from source R = np.sqrt((X - source[0])**2 + (Y - source[1])**2) # Wave function def wave_frame(t): return A * np.sin(k * R - \u03c9 * t + phi) # Static heatmap plt.figure(figsize=(6, 6)) plt.imshow(wave_frame(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') plt.title('Single Source - Heatmap') plt.colorbar(label='Amplitude') plt.show() Visit: Colab","title":"1. Single Source Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#animation","text":"fig, ax = plt.subplots(figsize=(6, 6)) im = ax.imshow(wave_frame(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') ax.set_title('Single Source Wave Animation') def animate(t): im.set_array(wave_frame(t)) return [im] ani = animation.FuncAnimation(fig, animate, frames=np.linspace(0, 2, 60), interval=100, blit=True) HTML(ani.to_jshtml()) Visit: Colab","title":"Animation:"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#2-two-sources-interference","text":"sources = [(-3, 0), (3, 0)] def interference_frame(t): total = np.zeros_like(X) for sx, sy in sources: R = np.sqrt((X - sx)**2 + (Y - sy)**2) total += A * np.sin(k * R - \u03c9 * t) return total # Static Interference Heatmap plt.figure(figsize=(6, 6)) plt.imshow(interference_frame(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') plt.title('Two Sources - Heatmap') plt.colorbar(label='Amplitude') plt.show() Visit: Colab","title":"2. Two Sources Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#animation_1","text":"fig, ax = plt.subplots(figsize=(6, 6)) im = ax.imshow(interference_frame(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') ax.set_title('Two Source Interference Animation') def animate(t): im.set_array(interference_frame(t)) return [im] ani = animation.FuncAnimation(fig, animate, frames=np.linspace(0, 2, 60), interval=100, blit=True) HTML(ani.to_jshtml()) Visit: Colab","title":"Animation:"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-polygon-sources-triangle-square-pentagon","text":"def generate_polygon_sources(n, radius=5): return [(radius * np.cos(2 * np.pi * i / n), radius * np.sin(2 * np.pi * i / n)) for i in range(n)] # Choose n = 3, 4, 5 for triangle, square, pentagon sources = generate_polygon_sources(n=5) def polygon_wave(t): total = np.zeros_like(X) for sx, sy in sources: R = np.sqrt((X - sx)**2 + (Y - sy)**2) total += A * np.sin(k * R - \u03c9 * t) return total # Static plt.figure(figsize=(6, 6)) plt.imshow(polygon_wave(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') plt.title('Interference from Pentagon Vertices') plt.colorbar(label='Amplitude') plt.show() Visit: Colab","title":"3. Polygon Sources (Triangle, Square, Pentagon)"},{"location":"1%20Physics/3%20Waves/Problem_1/#polygon-animation","text":"fig, ax = plt.subplots(figsize=(6, 6)) im = ax.imshow(polygon_wave(0), extent=[-10, 10, -10, 10], cmap='RdBu', origin='lower') ax.set_title('Polygon Source Interference Animation') def animate(t): im.set_array(polygon_wave(t)) return [im] ani = animation.FuncAnimation(fig, animate, frames=np.linspace(0, 2, 60), interval=100, blit=True) HTML(ani.to_jshtml()) Visit: Colab","title":"Polygon Animation:"},{"location":"1%20Physics/3%20Waves/Problem_1/#3d-visualization","text":"from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') Z = polygon_wave(0) ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(\"3D Interference from Polygon\") ax.set_zlim(-2, 2) plt.show() Visit: Colab","title":"3D Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#summary","text":"Case Sources Description 1 Single Basic circular wave 2 Two Shows constructive/destructive lines 3 Triangle/Square/Pentagon Complex interference lattices","title":"Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Electromagnetism: Lorentz Force & Trajectories of Charged Particles Motivation Understanding how charged particles move in electromagnetic fields is essential for: Plasma physics Particle accelerators Magnetic confinement in fusion Mass spectrometry Astrophysics and space weather We focus on the Lorentz Force , which governs the motion of a charged particle in electric and magnetic fields. This force alters the trajectory, causing particles to spiral, drift, or move in circles depending on initial conditions. Lorentz Force Equation The Lorentz Force on a particle of charge \\(q\\) is given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\(\\vec{E}\\) : electric field \\(\\vec{B}\\) : magnetic field \\(\\vec{v}\\) : velocity of the particle For now, we will focus on magnetic field only : \\[ \\vec{F} = q (\\vec{v} \\times \\vec{B}) \\] Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{d\\vec{v}}{dt} = \\frac{\\vec{F}}{m} = \\frac{q}{m} (\\vec{v} \\times \\vec{B}) \\] We solve this system numerically using time-stepping. Physical Intuition If \\(\\vec{v} \\perp \\vec{B}\\) : the particle undergoes circular motion If \\(\\vec{v}\\) has a component parallel to \\(\\vec{B}\\) : spiral motion If \\(\\vec{E} \\neq 0\\) : can result in drift motion Animation Code (Spiral Case) from matplotlib import animation from IPython.display import HTML def animate_trajectory(traj): fig = plt.figure(figsize=(6, 5)) ax = fig.add_subplot(111, projection='3d') ax.set_xlim(np.min(traj[:,0]), np.max(traj[:,0])) ax.set_ylim(np.min(traj[:,1]), np.max(traj[:,1])) ax.set_zlim(np.min(traj[:,2]), np.max(traj[:,2])) line, = ax.plot([], [], [], lw=2) def init(): line.set_data([], []) line.set_3d_properties([]) return line, def update(frame): line.set_data(traj[:frame, 0], traj[:frame, 1]) line.set_3d_properties(traj[:frame, 2]) return line, ani = animation.FuncAnimation(fig, update, frames=len(traj), init_func=init, interval=40, blit=True) return ani spiral = simulate_trajectory(np.array([1.0, 0.0, 0.5]), np.array([0.0, 0.0, 0.0])) ani = animate_trajectory(spiral) HTML(ani.to_jshtml()) Visit: Colab import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML # Physical constants q = 1.0 # charge in C m = 0.001 # mass in kg B = np.array([0, 0, 1]) # magnetic field in z direction (T) E = np.array([0, 0, 0]) # electric field (optional) v0 = np.array([1., 1., 0.5]) # initial velocity in m/s - Changed to float r0 = np.array([0., 0., 0.]) # initial position - Changed to float # Time settings dt = 0.001 # Reduced time step steps = 1000 # Reduced number of steps # Arrays to store trajectory positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Simulation (Euler method) for i in range(1, steps): v = velocities[i-1] a = (q / m) * (E + np.cross(v, B)) velocities[i] = v + a * dt positions[i] = positions[i-1] + velocities[i] * dt # --- 3D Animation --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Adjust limits based on trajectory data ax.set_xlim(np.min(positions[:,0]), np.max(positions[:,0])) ax.set_ylim(np.min(positions[:,1]), np.max(positions[:,1])) ax.set_zlim(np.min(positions[:,2]), np.max(positions[:,2])) ax.set_title(\"Lorentz Force: Particle Trajectory\") line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def init(): line.set_data([], []) line.set_3d_properties([]) point.set_data([], []) point.set_3d_properties([]) return line, point def update(frame): line.set_data(positions[:frame, 0], positions[:frame, 1]) line.set_3d_properties(positions[:frame, 2]) # Pass coordinates as sequences for the point point.set_data([positions[frame, 0]], [positions[frame, 1]]) point.set_3d_properties([positions[frame, 2]]) return line, point ani = FuncAnimation(fig, update, frames=range(0, steps, 10), init_func=init, blit=True, interval=30) HTML(ani.to_jshtml()) # For Colab inline display Visit: Colab # Constants q = 1.0 # charge (Coulombs) m = 1.0 # mass (kg) B = np.array([0, 0, 1.0]) # Magnetic field along z dt = 0.01 steps = 1000 def simulate_motion(v0, r0, E=np.array([0.0, 0.0, 0.0]), damping=0.0): r = np.zeros((steps, 3)) v = v0.copy() r[0] = r0.copy() for i in range(1, steps): F = q * (np.cross(v, B) + E) a = F / m v += a * dt v *= (1.0 - damping) r[i] = r[i - 1] + v * dt return r # 1. Circular trajectory: v \u22a5 B, no E field r_circular = simulate_motion(np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])) # 2. E x B drift: add electric field in x direction, v in y r_drift = simulate_motion(np.array([0.0, 1.0, 0.0]), np.array([0.0, 0.0, 0.0]), E=np.array([1.0, 0.0, 0.0])) # 3. Spiral motion: add z-component to velocity and weak damping r_spiral = simulate_motion(np.array([1.0, 0.0, 0.5]), np.array([0.0, 1.0, 0.0]), damping=0.001) # Plotting fig = plt.figure(figsize=(12, 9)) # Plot 1: Circular ax1 = fig.add_subplot(311, projection='3d') ax1.plot(r_circular[:, 0], r_circular[:, 1], r_circular[:, 2], color='blue') ax1.set_title(\"Circular Trajectory in Magnetic Field\") ax1.set_xlabel(\"X\") ax1.set_ylabel(\"Y\") ax1.set_zlabel(\"Z\") # Plot 2: E x B drift ax2 = fig.add_subplot(312, projection='3d') ax2.plot(r_drift[:, 0], r_drift[:, 1], r_drift[:, 2], color='blue') ax2.set_title(\"E \u00d7 B Drift of Charged Particle\") ax2.set_xlabel(\"X\") ax2.set_ylabel(\"Y\") ax2.set_zlabel(\"Z\") # Plot 3: Spiral ax3 = fig.add_subplot(313, projection='3d') ax3.plot(r_spiral[:, 0], r_spiral[:, 1], r_spiral[:, 2], color='blue') ax3.set_title(\"Stable Spiral Trajectory in Magnetic Field\") ax3.set_xlabel(\"X\") ax3.set_ylabel(\"Y\") ax3.set_zlabel(\"Z\") plt.tight_layout() plt.show() Insights The Lorentz force is always perpendicular to velocity \u21d2 no work done \u21d2 speed constant. Radius of circular motion: \\[ r = \\frac{mv}{qB} \\] Period of rotation: \\[ T = \\frac{2\\pi m}{qB} \\] Electric fields induce drift depending on E \u22a5 B direction.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-trajectories-of-charged-particles","text":"","title":"Electromagnetism: Lorentz Force &amp; Trajectories of Charged Particles"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"Understanding how charged particles move in electromagnetic fields is essential for: Plasma physics Particle accelerators Magnetic confinement in fusion Mass spectrometry Astrophysics and space weather We focus on the Lorentz Force , which governs the motion of a charged particle in electric and magnetic fields. This force alters the trajectory, causing particles to spiral, drift, or move in circles depending on initial conditions.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-equation","text":"The Lorentz Force on a particle of charge \\(q\\) is given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\(\\vec{E}\\) : electric field \\(\\vec{B}\\) : magnetic field \\(\\vec{v}\\) : velocity of the particle For now, we will focus on magnetic field only : \\[ \\vec{F} = q (\\vec{v} \\times \\vec{B}) \\] Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{d\\vec{v}}{dt} = \\frac{\\vec{F}}{m} = \\frac{q}{m} (\\vec{v} \\times \\vec{B}) \\] We solve this system numerically using time-stepping.","title":"Lorentz Force Equation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-intuition","text":"If \\(\\vec{v} \\perp \\vec{B}\\) : the particle undergoes circular motion If \\(\\vec{v}\\) has a component parallel to \\(\\vec{B}\\) : spiral motion If \\(\\vec{E} \\neq 0\\) : can result in drift motion","title":"Physical Intuition"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#animation-code-spiral-case","text":"from matplotlib import animation from IPython.display import HTML def animate_trajectory(traj): fig = plt.figure(figsize=(6, 5)) ax = fig.add_subplot(111, projection='3d') ax.set_xlim(np.min(traj[:,0]), np.max(traj[:,0])) ax.set_ylim(np.min(traj[:,1]), np.max(traj[:,1])) ax.set_zlim(np.min(traj[:,2]), np.max(traj[:,2])) line, = ax.plot([], [], [], lw=2) def init(): line.set_data([], []) line.set_3d_properties([]) return line, def update(frame): line.set_data(traj[:frame, 0], traj[:frame, 1]) line.set_3d_properties(traj[:frame, 2]) return line, ani = animation.FuncAnimation(fig, update, frames=len(traj), init_func=init, interval=40, blit=True) return ani spiral = simulate_trajectory(np.array([1.0, 0.0, 0.5]), np.array([0.0, 0.0, 0.0])) ani = animate_trajectory(spiral) HTML(ani.to_jshtml()) Visit: Colab import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML # Physical constants q = 1.0 # charge in C m = 0.001 # mass in kg B = np.array([0, 0, 1]) # magnetic field in z direction (T) E = np.array([0, 0, 0]) # electric field (optional) v0 = np.array([1., 1., 0.5]) # initial velocity in m/s - Changed to float r0 = np.array([0., 0., 0.]) # initial position - Changed to float # Time settings dt = 0.001 # Reduced time step steps = 1000 # Reduced number of steps # Arrays to store trajectory positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Simulation (Euler method) for i in range(1, steps): v = velocities[i-1] a = (q / m) * (E + np.cross(v, B)) velocities[i] = v + a * dt positions[i] = positions[i-1] + velocities[i] * dt # --- 3D Animation --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Adjust limits based on trajectory data ax.set_xlim(np.min(positions[:,0]), np.max(positions[:,0])) ax.set_ylim(np.min(positions[:,1]), np.max(positions[:,1])) ax.set_zlim(np.min(positions[:,2]), np.max(positions[:,2])) ax.set_title(\"Lorentz Force: Particle Trajectory\") line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def init(): line.set_data([], []) line.set_3d_properties([]) point.set_data([], []) point.set_3d_properties([]) return line, point def update(frame): line.set_data(positions[:frame, 0], positions[:frame, 1]) line.set_3d_properties(positions[:frame, 2]) # Pass coordinates as sequences for the point point.set_data([positions[frame, 0]], [positions[frame, 1]]) point.set_3d_properties([positions[frame, 2]]) return line, point ani = FuncAnimation(fig, update, frames=range(0, steps, 10), init_func=init, blit=True, interval=30) HTML(ani.to_jshtml()) # For Colab inline display Visit: Colab # Constants q = 1.0 # charge (Coulombs) m = 1.0 # mass (kg) B = np.array([0, 0, 1.0]) # Magnetic field along z dt = 0.01 steps = 1000 def simulate_motion(v0, r0, E=np.array([0.0, 0.0, 0.0]), damping=0.0): r = np.zeros((steps, 3)) v = v0.copy() r[0] = r0.copy() for i in range(1, steps): F = q * (np.cross(v, B) + E) a = F / m v += a * dt v *= (1.0 - damping) r[i] = r[i - 1] + v * dt return r # 1. Circular trajectory: v \u22a5 B, no E field r_circular = simulate_motion(np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])) # 2. E x B drift: add electric field in x direction, v in y r_drift = simulate_motion(np.array([0.0, 1.0, 0.0]), np.array([0.0, 0.0, 0.0]), E=np.array([1.0, 0.0, 0.0])) # 3. Spiral motion: add z-component to velocity and weak damping r_spiral = simulate_motion(np.array([1.0, 0.0, 0.5]), np.array([0.0, 1.0, 0.0]), damping=0.001) # Plotting fig = plt.figure(figsize=(12, 9)) # Plot 1: Circular ax1 = fig.add_subplot(311, projection='3d') ax1.plot(r_circular[:, 0], r_circular[:, 1], r_circular[:, 2], color='blue') ax1.set_title(\"Circular Trajectory in Magnetic Field\") ax1.set_xlabel(\"X\") ax1.set_ylabel(\"Y\") ax1.set_zlabel(\"Z\") # Plot 2: E x B drift ax2 = fig.add_subplot(312, projection='3d') ax2.plot(r_drift[:, 0], r_drift[:, 1], r_drift[:, 2], color='blue') ax2.set_title(\"E \u00d7 B Drift of Charged Particle\") ax2.set_xlabel(\"X\") ax2.set_ylabel(\"Y\") ax2.set_zlabel(\"Z\") # Plot 3: Spiral ax3 = fig.add_subplot(313, projection='3d') ax3.plot(r_spiral[:, 0], r_spiral[:, 1], r_spiral[:, 2], color='blue') ax3.set_title(\"Stable Spiral Trajectory in Magnetic Field\") ax3.set_xlabel(\"X\") ax3.set_ylabel(\"Y\") ax3.set_zlabel(\"Z\") plt.tight_layout() plt.show()","title":"Animation Code (Spiral Case)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#insights","text":"The Lorentz force is always perpendicular to velocity \u21d2 no work done \u21d2 speed constant. Radius of circular motion: \\[ r = \\frac{mv}{qB} \\] Period of rotation: \\[ T = \\frac{2\\pi m}{qB} \\] Electric fields induce drift depending on E \u22a5 B direction.","title":"Insights"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 1. Circuit Foundations: Theoretical Basis Series Rule: If node A connects to node B, which connects to node C (and B has degree 2): \\[ R_{\\text{eq}} = R_{AB} + R_{BC} \\] Parallel Rule: If multiple edges connect the same pair of nodes: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots \\] Kirchhoff\u2019s Voltage Law (KVL): \\[ \\sum \\text{Voltage drops in a loop} = 0 \\] For an RLC loop: \\[ V(t) = i(t)R + L\\frac{di(t)}{dt} + \\frac{1}{C} \\int i(t)\\,dt \\] Kirchhoff\u2019s Current Law (KCL): \\[ \\sum \\text{Currents into a node} = \\sum \\text{Currents out} \\] RLC Circuits Using charge \\(q(t)\\) , where \\(i(t) = \\frac{dq}{dt}\\) : \\[ L \\frac{d^2q(t)}{dt^2} + R \\frac{dq(t)}{dt} + \\frac{1}{C} q(t) = V(t) \\] 2. Steady-State and Resistance In steady-state (DC analysis): \\(\\frac{dq}{dt} = 0\\) , \\(\\frac{d^2q}{dt^2} = 0\\) Inductors = short circuits Capacitors = open circuits Only resistors matter So we simplify using: \\[ V = IR \\quad \\Rightarrow \\quad R_{\\text{eq}} = \\frac{V}{I} \\] 3. Graph-Theoretic Circuit Model Concept Description Node Junction (graph vertex) Edge Resistor (weight = resistance in \u03a9) START, END Circuit terminals Series Degree-2 node (collapsible path) Parallel Multiple edges between same two nodes # Install required libraries !pip install networkx matplotlib --quiet # Imports import networkx as nx import matplotlib.pyplot as plt # Draw circuit graph def draw_graph(G, title=\"Circuit\"): pos = nx.spring_layout(G, seed=42) labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000, font_size=14) nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color='red') plt.title(title) plt.axis('off') plt.show() # Collapse series resistors def collapse_series(G, start=\"START\", end=\"END\"): changed = True while changed: changed = False for node in list(G.nodes): if G.degree[node] == 2 and node not in (start, end): u, v = list(G.neighbors(node)) if G.has_edge(u, node) and G.has_edge(node, v): r1 = G[u][node]['resistance'] r2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=r1 + r2) G.remove_node(node) changed = True break return G # Collapse parallel resistors def collapse_parallel(G): merged = set() for u, v in list(G.edges()): if (u, v) in merged or (v, u) in merged: continue edges = list(G.get_edge_data(u, v).values()) if len(edges) > 1: resistances = [d['resistance'] for d in edges] r_eq = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v)] * len(edges)) G.add_edge(u, v, resistance=r_eq) merged.add((u, v)) return G # Main function def compute_equivalent_resistance(G, start=\"START\", end=\"END\", show_steps=True): if show_steps: draw_graph(G, \"Original Circuit\") changed = True while changed: prev_edges = G.number_of_edges() G = collapse_series(G, start, end) G = collapse_parallel(G) changed = (G.number_of_edges() != prev_edges) if show_steps: draw_graph(G, \"Simplified Step\") return G[start][end]['resistance'] # Example circuit: START - A - END in series, plus a parallel edge G = nx.MultiGraph() G.add_edge(\"START\", \"A\", resistance=5) G.add_edge(\"A\", \"END\", resistance=10) G.add_edge(\"START\", \"END\", resistance=15) # Parallel resistor # Run and visualize req = compute_equivalent_resistance(G, \"START\", \"END\", show_steps=True) print(f\" Equivalent Resistance: {req:.2f} \u03a9\") Visit: Colab # Series Only: START \u2014 10\u03a9 \u2014 A \u2014 20\u03a9 \u2014 END G1 = nx.MultiGraph() G1.add_edge(\"START\", \"A\", resistance=10) G1.add_edge(\"A\", \"END\", resistance=20) req1 = compute_equivalent_resistance(G1.copy(), \"START\", \"END\", show_steps=True) print(f\"Series Example \u2192 Equivalent Resistance: {req1:.2f} \u03a9\") Visit: Colab # Parallel Only: START \u2014 10\u03a9 \u2014 END, START \u2014 20\u03a9 \u2014 END G2 = nx.MultiGraph() G2.add_edge(\"START\", \"END\", resistance=10) G2.add_edge(\"START\", \"END\", resistance=20) req2 = compute_equivalent_resistance(G2.copy(), \"START\", \"END\", show_steps=True) print(f\"Parallel Example \u2192 Equivalent Resistance: {req2:.2f} \u03a9\") Visit: Colab # Nested: two series resistors in parallel with one resistor # START \u2014 5\u03a9 \u2014 A \u2014 5\u03a9 \u2014 END # \\__________15\u03a9_________/ G3 = nx.MultiGraph() G3.add_edge(\"START\", \"A\", resistance=5) G3.add_edge(\"A\", \"END\", resistance=5) G3.add_edge(\"START\", \"END\", resistance=15) req3 = compute_equivalent_resistance(G3.copy(), \"START\", \"END\", show_steps=True) print(f\"Nested Example \u2192 Equivalent Resistance: {req3:.2f} \u03a9\") Visit: Colab # Diamond: START \u2014 A \u2014 END, START \u2014 B \u2014 END # All resistors = 10\u03a9 G4 = nx.MultiGraph() G4.add_edge(\"START\", \"A\", resistance=10) G4.add_edge(\"A\", \"END\", resistance=10) G4.add_edge(\"START\", \"B\", resistance=10) G4.add_edge(\"B\", \"END\", resistance=10) req4 = compute_equivalent_resistance(G4.copy(), \"START\", \"END\", show_steps=True) print(f\"Diamond Example \u2192 Equivalent Resistance: {req4:.2f} \u03a9\") Visit: Colab 4. Animation from matplotlib import animation from IPython.display import HTML # Global frame list animation_frames = [] def draw_graph_for_animation(G, title=\"\"): fig, ax = plt.subplots() pos = nx.spring_layout(G, seed=42) labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000, ax=ax) nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color='red', ax=ax) ax.set_title(title) ax.axis('off') animation_frames.append(fig) def compute_equivalent_resistance_animated(G, start=\"START\", end=\"END\"): animation_frames.clear() draw_graph_for_animation(G.copy(), \"Original Circuit\") changed = True while changed: prev_edges = G.number_of_edges() G = collapse_series(G, start, end) G = collapse_parallel(G) changed = (G.number_of_edges() != prev_edges) draw_graph_for_animation(G.copy(), \"Simplified Step\") return G[start][end]['resistance'] # Define your test circuit (e.g., diamond or nested) G_example = nx.MultiGraph() G_example.add_edge(\"START\", \"A\", resistance=5) G_example.add_edge(\"A\", \"END\", resistance=5) G_example.add_edge(\"START\", \"END\", resistance=15) # Run the animation-enabled simplification req = compute_equivalent_resistance_animated(G_example, \"START\", \"END\") print(f\"Animated Result: {req:.2f} \u03a9\") Visit: Colab # Create animation fig = animation_frames[0] fig.set_size_inches(6, 6) ani = animation.ArtistAnimation(fig, [f.axes[0].images + f.axes[0].texts for f in animation_frames], interval=1500, repeat_delay=1000, blit=False) # Display the animation HTML(ani.to_jshtml()) Visit: Colab 5. Example Interpretation This circuit: START \u2014 5\u03a9 \u2014 A \u2014 10\u03a9 \u2014 END \\________________/ 15\u03a9 Reduces to: Series path = 15\u03a9 In parallel with 15\u03a9 \u2192 final R_eq = 7.5\u03a9 6. Applications Circuit simulation software Hardware simplification Engineering education Algorithmic analysis of networks","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-circuit-foundations-theoretical-basis","text":"","title":"1. Circuit Foundations: Theoretical Basis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-rule","text":"If node A connects to node B, which connects to node C (and B has degree 2): \\[ R_{\\text{eq}} = R_{AB} + R_{BC} \\]","title":"Series Rule:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-rule","text":"If multiple edges connect the same pair of nodes: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots \\]","title":"Parallel Rule:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#kirchhoffs-voltage-law-kvl","text":"\\[ \\sum \\text{Voltage drops in a loop} = 0 \\] For an RLC loop: \\[ V(t) = i(t)R + L\\frac{di(t)}{dt} + \\frac{1}{C} \\int i(t)\\,dt \\]","title":"Kirchhoff\u2019s Voltage Law (KVL):"},{"location":"1%20Physics/5%20Circuits/Problem_1/#kirchhoffs-current-law-kcl","text":"\\[ \\sum \\text{Currents into a node} = \\sum \\text{Currents out} \\]","title":"Kirchhoff\u2019s Current Law (KCL):"},{"location":"1%20Physics/5%20Circuits/Problem_1/#rlc-circuits","text":"Using charge \\(q(t)\\) , where \\(i(t) = \\frac{dq}{dt}\\) : \\[ L \\frac{d^2q(t)}{dt^2} + R \\frac{dq(t)}{dt} + \\frac{1}{C} q(t) = V(t) \\]","title":"RLC Circuits"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-steady-state-and-resistance","text":"In steady-state (DC analysis): \\(\\frac{dq}{dt} = 0\\) , \\(\\frac{d^2q}{dt^2} = 0\\) Inductors = short circuits Capacitors = open circuits Only resistors matter So we simplify using: \\[ V = IR \\quad \\Rightarrow \\quad R_{\\text{eq}} = \\frac{V}{I} \\]","title":"2. Steady-State and Resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-graph-theoretic-circuit-model","text":"Concept Description Node Junction (graph vertex) Edge Resistor (weight = resistance in \u03a9) START, END Circuit terminals Series Degree-2 node (collapsible path) Parallel Multiple edges between same two nodes # Install required libraries !pip install networkx matplotlib --quiet # Imports import networkx as nx import matplotlib.pyplot as plt # Draw circuit graph def draw_graph(G, title=\"Circuit\"): pos = nx.spring_layout(G, seed=42) labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000, font_size=14) nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color='red') plt.title(title) plt.axis('off') plt.show() # Collapse series resistors def collapse_series(G, start=\"START\", end=\"END\"): changed = True while changed: changed = False for node in list(G.nodes): if G.degree[node] == 2 and node not in (start, end): u, v = list(G.neighbors(node)) if G.has_edge(u, node) and G.has_edge(node, v): r1 = G[u][node]['resistance'] r2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=r1 + r2) G.remove_node(node) changed = True break return G # Collapse parallel resistors def collapse_parallel(G): merged = set() for u, v in list(G.edges()): if (u, v) in merged or (v, u) in merged: continue edges = list(G.get_edge_data(u, v).values()) if len(edges) > 1: resistances = [d['resistance'] for d in edges] r_eq = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v)] * len(edges)) G.add_edge(u, v, resistance=r_eq) merged.add((u, v)) return G # Main function def compute_equivalent_resistance(G, start=\"START\", end=\"END\", show_steps=True): if show_steps: draw_graph(G, \"Original Circuit\") changed = True while changed: prev_edges = G.number_of_edges() G = collapse_series(G, start, end) G = collapse_parallel(G) changed = (G.number_of_edges() != prev_edges) if show_steps: draw_graph(G, \"Simplified Step\") return G[start][end]['resistance'] # Example circuit: START - A - END in series, plus a parallel edge G = nx.MultiGraph() G.add_edge(\"START\", \"A\", resistance=5) G.add_edge(\"A\", \"END\", resistance=10) G.add_edge(\"START\", \"END\", resistance=15) # Parallel resistor # Run and visualize req = compute_equivalent_resistance(G, \"START\", \"END\", show_steps=True) print(f\" Equivalent Resistance: {req:.2f} \u03a9\") Visit: Colab # Series Only: START \u2014 10\u03a9 \u2014 A \u2014 20\u03a9 \u2014 END G1 = nx.MultiGraph() G1.add_edge(\"START\", \"A\", resistance=10) G1.add_edge(\"A\", \"END\", resistance=20) req1 = compute_equivalent_resistance(G1.copy(), \"START\", \"END\", show_steps=True) print(f\"Series Example \u2192 Equivalent Resistance: {req1:.2f} \u03a9\") Visit: Colab # Parallel Only: START \u2014 10\u03a9 \u2014 END, START \u2014 20\u03a9 \u2014 END G2 = nx.MultiGraph() G2.add_edge(\"START\", \"END\", resistance=10) G2.add_edge(\"START\", \"END\", resistance=20) req2 = compute_equivalent_resistance(G2.copy(), \"START\", \"END\", show_steps=True) print(f\"Parallel Example \u2192 Equivalent Resistance: {req2:.2f} \u03a9\") Visit: Colab # Nested: two series resistors in parallel with one resistor # START \u2014 5\u03a9 \u2014 A \u2014 5\u03a9 \u2014 END # \\__________15\u03a9_________/ G3 = nx.MultiGraph() G3.add_edge(\"START\", \"A\", resistance=5) G3.add_edge(\"A\", \"END\", resistance=5) G3.add_edge(\"START\", \"END\", resistance=15) req3 = compute_equivalent_resistance(G3.copy(), \"START\", \"END\", show_steps=True) print(f\"Nested Example \u2192 Equivalent Resistance: {req3:.2f} \u03a9\") Visit: Colab # Diamond: START \u2014 A \u2014 END, START \u2014 B \u2014 END # All resistors = 10\u03a9 G4 = nx.MultiGraph() G4.add_edge(\"START\", \"A\", resistance=10) G4.add_edge(\"A\", \"END\", resistance=10) G4.add_edge(\"START\", \"B\", resistance=10) G4.add_edge(\"B\", \"END\", resistance=10) req4 = compute_equivalent_resistance(G4.copy(), \"START\", \"END\", show_steps=True) print(f\"Diamond Example \u2192 Equivalent Resistance: {req4:.2f} \u03a9\") Visit: Colab","title":"3. Graph-Theoretic Circuit Model"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-animation","text":"from matplotlib import animation from IPython.display import HTML # Global frame list animation_frames = [] def draw_graph_for_animation(G, title=\"\"): fig, ax = plt.subplots() pos = nx.spring_layout(G, seed=42) labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000, ax=ax) nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color='red', ax=ax) ax.set_title(title) ax.axis('off') animation_frames.append(fig) def compute_equivalent_resistance_animated(G, start=\"START\", end=\"END\"): animation_frames.clear() draw_graph_for_animation(G.copy(), \"Original Circuit\") changed = True while changed: prev_edges = G.number_of_edges() G = collapse_series(G, start, end) G = collapse_parallel(G) changed = (G.number_of_edges() != prev_edges) draw_graph_for_animation(G.copy(), \"Simplified Step\") return G[start][end]['resistance'] # Define your test circuit (e.g., diamond or nested) G_example = nx.MultiGraph() G_example.add_edge(\"START\", \"A\", resistance=5) G_example.add_edge(\"A\", \"END\", resistance=5) G_example.add_edge(\"START\", \"END\", resistance=15) # Run the animation-enabled simplification req = compute_equivalent_resistance_animated(G_example, \"START\", \"END\") print(f\"Animated Result: {req:.2f} \u03a9\") Visit: Colab # Create animation fig = animation_frames[0] fig.set_size_inches(6, 6) ani = animation.ArtistAnimation(fig, [f.axes[0].images + f.axes[0].texts for f in animation_frames], interval=1500, repeat_delay=1000, blit=False) # Display the animation HTML(ani.to_jshtml()) Visit: Colab","title":"4. Animation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-example-interpretation","text":"This circuit: START \u2014 5\u03a9 \u2014 A \u2014 10\u03a9 \u2014 END \\________________/ 15\u03a9 Reduces to: Series path = 15\u03a9 In parallel with 15\u03a9 \u2192 final R_eq = 7.5\u03a9","title":"5. Example Interpretation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-applications","text":"Circuit simulation software Hardware simplification Engineering education Algorithmic analysis of networks","title":"6. Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 1. Theoretical Background What is the Central Limit Theorem? The Central Limit Theorem (CLT) is a fundamental result in statistics that explains why the normal distribution arises so frequently in practice. It states: Given a population with any shape distribution (with finite mean \u03bc and variance \u03c3\u00b2), the distribution of the sample means (\ud835\udc4b\u0304) of sufficiently large random samples will approach a normal distribution as the sample size (n) increases. This happens regardless of the shape of the original distribution \u2014 it could be skewed, uniform, or binomial \u2014 and yet the distribution of the sample means becomes approximately normal for large enough sample sizes. 2. Key Formulas Let \\(X_1, X_2, \\dots, X_n\\) be independent and identically distributed (i.i.d.) random variables from some population with: Mean \\(\\mu = E[X_i]\\) Variance \\(\\sigma^2 = Var(X_i)\\) Then, the sample mean is: \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] The expected value and variance of the sample mean are: \\(E[\\bar{X}] = \\mu\\) \\(Var(\\bar{X}) = \\frac{\\sigma^2}{n}\\) According to the CLT: \\[ \\frac{\\bar{X} - \\mu}{\\sigma / \\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) \\quad \\text{as } n \\to \\infty \\] 3. Understanding Through Simulations We will simulate the CLT using three different population distributions: Uniform Distribution Exponential Distribution Binomial Distribution For each distribution: We generate a large population. Draw multiple random samples. Calculate the sample mean for different sample sizes. Plot the sampling distribution of the sample mean. 4. Python Implementation import numpy as np import matplotlib.pyplot as plt import seaborn as sns from matplotlib.animation import FuncAnimation from IPython.display import HTML sns.set(style=\"whitegrid\") # Settings population_sample_size = 100000 num_samples = 1000 sample_sizes = [5, 10, 30, 50] Population Generators # Define distributions population_distributions = { 'Uniform(0,1)': lambda size: np.random.uniform(0, 1, size), 'Exponential(\u03bb=1)': lambda size: np.random.exponential(scale=1.0, size=size), 'Binomial(n=10, p=0.5)': lambda size: np.random.binomial(n=10, p=0.5, size=size) } Function to Plot Sampling Distribution def plot_sampling_distribution(dist_name, generator): population = generator(population_sample_size) fig, axes = plt.subplots(1, len(sample_sizes), figsize=(20, 4)) fig.suptitle(f'Sampling Distribution of Sample Mean ({dist_name})', fontsize=16) for idx, n in enumerate(sample_sizes): sample_means = [np.mean(generator(n)) for _ in range(num_samples)] sns.histplot(sample_means, kde=True, bins=30, ax=axes[idx], color=\"skyblue\") axes[idx].set_title(f'Sample size n = {n}') axes[idx].set_xlabel('Sample Mean') axes[idx].set_ylabel('Frequency') plt.tight_layout() plt.show() Generate Sampling Distributions for name, gen in population_distributions.items(): plot_sampling_distribution(name, gen) Visit: Colab 5. Animation: How the Sample Mean Converges We animate the build-up of sample means from the Exponential distribution . # Animation for Exponential Distribution sample_means = [] fig, ax = plt.subplots(figsize=(6, 4)) def animate(i): ax.clear() sample = np.random.exponential(scale=1.0, size=30) sample_means.append(np.mean(sample)) sns.histplot(sample_means, kde=True, bins=30, ax=ax, color=\"orange\") ax.set_xlim(0, 3) ax.set_ylim(0, 150) ax.set_title(f'Step {i+1}: CLT in Action') ani = FuncAnimation(fig, animate, frames=100, repeat=False) plt.close() HTML(ani.to_jshtml()) Visit: Colab 6. In-Depth Discussion Influence of Distribution Shape Distribution Shape CLT Behavior Uniform(0,1) Flat Fast convergence Exponential(\u03bb=1) Skewed right Slower convergence Binomial(10,0.5) Discrete Moderate convergence, quickly normal The more skewed or discrete the population, the larger the sample size needed for normality. All converge eventually, confirming the universality of the CLT . Influence of Variance The spread (standard deviation) of the sample means depends on: \\[ \\text{Standard deviation of the mean} = \\frac{\\sigma}{\\sqrt{n}} \\] \u2192 Larger sample sizes yield tighter, less variable distributions . 7. Real-World Applications of the CLT Manufacturing Quality control : CLT allows estimating the defect rate from a sample. Example: Testing 50 widgets out of 1000 to assess quality. Finance Predicting expected return on portfolios over time. Modeling risk by sampling past performance. Medicine & Biology Evaluating average effects of drugs on patient groups. Using sample averages in clinical trials to infer population behavior . Polling & Surveys Estimating population opinion from a representative sample. Used in election forecasting and public opinion research. 8. Summary Concept Explanation Central Limit Theorem Sample means approximate normal distribution as sample size increases Sample Mean \\(\\bar{X}\\) \\(\\bar{X} = \\frac{1}{n} \\sum X_i\\) Variance of Sample Mean \\(\\frac{\\sigma^2}{n}\\) Simulation Distributions Uniform, Exponential, Binomial Visualization Histograms, KDEs, Animation Key Insight Distribution shape and sample size influence convergence to normality","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-theoretical-background","text":"","title":"1. Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_1/#what-is-the-central-limit-theorem","text":"The Central Limit Theorem (CLT) is a fundamental result in statistics that explains why the normal distribution arises so frequently in practice. It states: Given a population with any shape distribution (with finite mean \u03bc and variance \u03c3\u00b2), the distribution of the sample means (\ud835\udc4b\u0304) of sufficiently large random samples will approach a normal distribution as the sample size (n) increases. This happens regardless of the shape of the original distribution \u2014 it could be skewed, uniform, or binomial \u2014 and yet the distribution of the sample means becomes approximately normal for large enough sample sizes.","title":"What is the Central Limit Theorem?"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-key-formulas","text":"Let \\(X_1, X_2, \\dots, X_n\\) be independent and identically distributed (i.i.d.) random variables from some population with: Mean \\(\\mu = E[X_i]\\) Variance \\(\\sigma^2 = Var(X_i)\\) Then, the sample mean is: \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] The expected value and variance of the sample mean are: \\(E[\\bar{X}] = \\mu\\) \\(Var(\\bar{X}) = \\frac{\\sigma^2}{n}\\) According to the CLT: \\[ \\frac{\\bar{X} - \\mu}{\\sigma / \\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) \\quad \\text{as } n \\to \\infty \\]","title":"2. Key Formulas"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-understanding-through-simulations","text":"We will simulate the CLT using three different population distributions: Uniform Distribution Exponential Distribution Binomial Distribution For each distribution: We generate a large population. Draw multiple random samples. Calculate the sample mean for different sample sizes. Plot the sampling distribution of the sample mean.","title":"3. Understanding Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns from matplotlib.animation import FuncAnimation from IPython.display import HTML sns.set(style=\"whitegrid\") # Settings population_sample_size = 100000 num_samples = 1000 sample_sizes = [5, 10, 30, 50]","title":"4. Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-generators","text":"# Define distributions population_distributions = { 'Uniform(0,1)': lambda size: np.random.uniform(0, 1, size), 'Exponential(\u03bb=1)': lambda size: np.random.exponential(scale=1.0, size=size), 'Binomial(n=10, p=0.5)': lambda size: np.random.binomial(n=10, p=0.5, size=size) }","title":"Population Generators"},{"location":"1%20Physics/6%20Statistics/Problem_1/#function-to-plot-sampling-distribution","text":"def plot_sampling_distribution(dist_name, generator): population = generator(population_sample_size) fig, axes = plt.subplots(1, len(sample_sizes), figsize=(20, 4)) fig.suptitle(f'Sampling Distribution of Sample Mean ({dist_name})', fontsize=16) for idx, n in enumerate(sample_sizes): sample_means = [np.mean(generator(n)) for _ in range(num_samples)] sns.histplot(sample_means, kde=True, bins=30, ax=axes[idx], color=\"skyblue\") axes[idx].set_title(f'Sample size n = {n}') axes[idx].set_xlabel('Sample Mean') axes[idx].set_ylabel('Frequency') plt.tight_layout() plt.show()","title":"Function to Plot Sampling Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#generate-sampling-distributions","text":"for name, gen in population_distributions.items(): plot_sampling_distribution(name, gen) Visit: Colab","title":"Generate Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-animation-how-the-sample-mean-converges","text":"We animate the build-up of sample means from the Exponential distribution . # Animation for Exponential Distribution sample_means = [] fig, ax = plt.subplots(figsize=(6, 4)) def animate(i): ax.clear() sample = np.random.exponential(scale=1.0, size=30) sample_means.append(np.mean(sample)) sns.histplot(sample_means, kde=True, bins=30, ax=ax, color=\"orange\") ax.set_xlim(0, 3) ax.set_ylim(0, 150) ax.set_title(f'Step {i+1}: CLT in Action') ani = FuncAnimation(fig, animate, frames=100, repeat=False) plt.close() HTML(ani.to_jshtml()) Visit: Colab","title":"5. Animation: How the Sample Mean Converges"},{"location":"1%20Physics/6%20Statistics/Problem_1/#6-in-depth-discussion","text":"","title":"6. In-Depth Discussion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#influence-of-distribution-shape","text":"Distribution Shape CLT Behavior Uniform(0,1) Flat Fast convergence Exponential(\u03bb=1) Skewed right Slower convergence Binomial(10,0.5) Discrete Moderate convergence, quickly normal The more skewed or discrete the population, the larger the sample size needed for normality. All converge eventually, confirming the universality of the CLT .","title":"Influence of Distribution Shape"},{"location":"1%20Physics/6%20Statistics/Problem_1/#influence-of-variance","text":"The spread (standard deviation) of the sample means depends on: \\[ \\text{Standard deviation of the mean} = \\frac{\\sigma}{\\sqrt{n}} \\] \u2192 Larger sample sizes yield tighter, less variable distributions .","title":"Influence of Variance"},{"location":"1%20Physics/6%20Statistics/Problem_1/#7-real-world-applications-of-the-clt","text":"","title":"7. Real-World Applications of the CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#manufacturing","text":"Quality control : CLT allows estimating the defect rate from a sample. Example: Testing 50 widgets out of 1000 to assess quality.","title":"Manufacturing"},{"location":"1%20Physics/6%20Statistics/Problem_1/#finance","text":"Predicting expected return on portfolios over time. Modeling risk by sampling past performance.","title":"Finance"},{"location":"1%20Physics/6%20Statistics/Problem_1/#medicine-biology","text":"Evaluating average effects of drugs on patient groups. Using sample averages in clinical trials to infer population behavior .","title":"Medicine &amp; Biology"},{"location":"1%20Physics/6%20Statistics/Problem_1/#polling-surveys","text":"Estimating population opinion from a representative sample. Used in election forecasting and public opinion research.","title":"Polling &amp; Surveys"},{"location":"1%20Physics/6%20Statistics/Problem_1/#8-summary","text":"Concept Explanation Central Limit Theorem Sample means approximate normal distribution as sample size increases Sample Mean \\(\\bar{X}\\) \\(\\bar{X} = \\frac{1}{n} \\sum X_i\\) Variance of Sample Mean \\(\\frac{\\sigma^2}{n}\\) Simulation Distributions Uniform, Exponential, Binomial Visualization Histograms, KDEs, Animation Key Insight Distribution shape and sample size influence convergence to normality","title":"8. Summary"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 PART 1: Estimating \u03c0 Using a Circle 1. Theoretical Foundation We inscribe a unit circle inside a square. The square has a side length of 2 (from \\([-1, 1]\\) in both \\(x\\) and \\(y\\) ), so its area is: \\[ A_{\\text{square}} = 2 \\times 2 = 4 \\] The area of the unit circle (radius \\(r = 1\\) ) is: \\[ A_{\\text{circle}} = \\pi \\cdot r^2 = \\pi \\] The ratio of the area of the circle to the square is: \\[ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] By randomly generating points in the square, the proportion that fall inside the circle should approximate \\(\\frac{\\pi}{4}\\) . Hence: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{# points inside circle}}{\\text{total # of points}} \\] 2. Simulation Code import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points # Visualization fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_title(f\"Estimation of \u03c0 = {pi_estimate:.6f} with {num_points} points\") ax.plot(x[inside], y[inside], 'b.', markersize=1, label='Inside Circle') ax.plot(x[~inside], y[~inside], 'r.', markersize=1, label='Outside Circle') ax.add_patch(plt.Circle((0, 0), 1, color='black', fill=False)) ax.legend() plt.grid(True) plt.show() return pi_estimate # Try with different sizes for n in [100, 1000, 10000, 100000]: estimate_pi_circle(n) Visit: Colab 3. Convergence Analysis import matplotlib.pyplot as plt def convergence_analysis_circle(max_points=100000, step=1000): estimates = [] x_vals = list(range(step, max_points + 1, step)) for n in x_vals: x = np.random.uniform(-1, 1, n) y = np.random.uniform(-1, 1, n) inside = x**2 + y**2 <= 1 pi_approx = 4 * np.sum(inside) / n estimates.append(pi_approx) plt.figure(figsize=(10, 5)) plt.plot(x_vals, estimates, label='Estimated \u03c0') plt.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0') plt.title(\"Convergence of \u03c0 Estimation using Circle Method\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() convergence_analysis_circle() Visit: Colab 4. Animation import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters n_points = 5000 # Total points step = 100 # Points per animation frame # Generate random points x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) r = x**2 + y**2 inside = r <= 1 # Set up the figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-1, 1) ax.set_ylim(-1, 1) ax.set_title(\"Estimating \u03c0 via Monte Carlo\") points_in, = ax.plot([], [], 'b.', markersize=1, label='Inside Circle') points_out, = ax.plot([], [], 'r.', markersize=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, fill=False, color='black') ax.add_artist(circle) ax.legend() # Animation update function def update(frame): idx = slice(0, step * (frame + 1)) points_in.set_data(x[idx][inside[idx]], y[idx][inside[idx]]) points_out.set_data(x[idx][~inside[idx]], y[idx][~inside[idx]]) current_pi = 4 * np.sum(inside[idx]) / len(x[idx]) ax.set_title(f\"Estimation of \u03c0: {current_pi:.5f} (n={len(x[idx])})\") return points_in, points_out frames = n_points // step ani = FuncAnimation(fig, update, frames=frames, interval=50, blit=True) plt.close() HTML(ani.to_jshtml()) Visit: Colab PART 2: Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Foundation In Buffon's Needle experiment, we drop a needle of length \\(L\\) onto a plane with parallel lines spaced \\(d\\) apart. Let: \\(L\\) = length of needle \\(d\\) = distance between lines \\(L \\leq d\\) The probability \\(P\\) that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\Rightarrow \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: \\(N\\) = total number of drops \\(C\\) = number of crosses 2. Simulation Code def simulate_buffon_needle(N=10000, L=1.0, d=2.0): assert L <= d, \"Needle length must be less than or equal to distance between lines\" # Random positions and angles theta = np.random.uniform(0, np.pi / 2, N) y = np.random.uniform(0, d / 2, N) crosses = y <= (L / 2) * np.sin(theta) C = np.sum(crosses) pi_estimate = (2 * L * N) / (C * d) if C > 0 else np.nan # Plot a few needles num_visual = 200 x_center = np.random.uniform(0, 10, num_visual) y_center = np.random.uniform(0, 10, num_visual) theta_visual = np.random.uniform(0, np.pi, num_visual) plt.figure(figsize=(10, 6)) for i in range(num_visual): x0 = x_center[i] - (L / 2) * np.cos(theta_visual[i]) y0 = y_center[i] - (L / 2) * np.sin(theta_visual[i]) x1 = x_center[i] + (L / 2) * np.cos(theta_visual[i]) y1 = y_center[i] + (L / 2) * np.sin(theta_visual[i]) color = 'blue' if np.floor(y0 / d) != np.floor(y1 / d) else 'gray' plt.plot([x0, x1], [y0, y1], color=color) for i in range(12): plt.axhline(i * d, color='black', linestyle='--', linewidth=0.5) plt.title(f\"Buffon's Needle Estimate of \u03c0 = {pi_estimate:.6f}\") plt.xlim(0, 10) plt.ylim(0, 10) plt.grid(True) plt.show() return pi_estimate simulate_buffon_needle() Visit: Colab 3. Convergence Analysis def convergence_analysis_buffon(N_max=10000, step=500, L=1.0, d=2.0): estimates = [] x_vals = [] for n in range(step, N_max + 1, step): theta = np.random.uniform(0, np.pi / 2, n) y = np.random.uniform(0, d / 2, n) crosses = y <= (L / 2) * np.sin(theta) C = np.sum(crosses) if C == 0: estimates.append(np.nan) else: pi_est = (2 * L * n) / (C * d) estimates.append(pi_est) x_vals.append(n) plt.figure(figsize=(10, 5)) plt.plot(x_vals, estimates, label=\"Estimated \u03c0\") plt.axhline(np.pi, color='red', linestyle='--', label=\"True \u03c0\") plt.title(\"Convergence of \u03c0 Estimation using Buffon's Needle\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() convergence_analysis_buffon() Visit: Colab import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters N = 500 # total needles step = 20 # needles per frame L = 0.8 # length of needle d = 1.0 # line spacing # Generate random angles and positions theta = np.random.uniform(0, np.pi, N) y_center = np.random.uniform(0, d/2, N) # Compute endpoints of needles x0 = np.zeros(N) y0 = y_center x1 = L/2 * np.cos(theta) y1 = L/2 * np.sin(theta) # Check crossing condition crosses = y_center <= (L/2) * np.sin(theta) # Setup plot fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1, 1) ax.set_ylim(0, d) ax.set_aspect('equal') ax.set_title(\"Buffon's Needle Simulation\") ax.hlines([0, d], -1, 1, colors='k', linewidth=1) needle_lines = [] def update(frame): global needle_lines for line in needle_lines: line.remove() needle_lines = [] end = min(N, (frame+1)*step) for i in range(end): x_start = -x1[i] x_end = x1[i] y_start = y0[i] - y1[i] y_end = y0[i] + y1[i] color = 'r' if crosses[i] else 'b' needle = ax.plot([x_start, x_end], [y_start, y_end], color=color, linewidth=1) needle_lines.extend(needle) if np.sum(crosses[:end]) > 0: pi_est = (2 * L * end) / (d * np.sum(crosses[:end])) ax.set_title(f\"Buffon's Needle \u03c0 \u2248 {pi_est:.5f} (n={end})\") else: ax.set_title(\"Waiting for first cross...\") return needle_lines frames = N // step ani = FuncAnimation(fig, update, frames=frames, interval=200, blit=False) plt.close() HTML(ani.to_jshtml()) Visit: Colab Comparison of Both Methods Method Accuracy (fast?) Simplicity Visualization Variance Circle Method Faster convergence Very easy Easy to plot Low to Medium Buffon's Needle Slower More complex Geometric High Summary Circle-based method uses 2D geometry and is fast and simple. Buffon\u2019s Needle is elegant and connects probability to geometry but converges more slowly. Both methods illustrate how randomness and computation can estimate mathematical constants.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"PART 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"We inscribe a unit circle inside a square. The square has a side length of 2 (from \\([-1, 1]\\) in both \\(x\\) and \\(y\\) ), so its area is: \\[ A_{\\text{square}} = 2 \\times 2 = 4 \\] The area of the unit circle (radius \\(r = 1\\) ) is: \\[ A_{\\text{circle}} = \\pi \\cdot r^2 = \\pi \\] The ratio of the area of the circle to the square is: \\[ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] By randomly generating points in the square, the proportion that fall inside the circle should approximate \\(\\frac{\\pi}{4}\\) . Hence: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{# points inside circle}}{\\text{total # of points}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points # Visualization fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_title(f\"Estimation of \u03c0 = {pi_estimate:.6f} with {num_points} points\") ax.plot(x[inside], y[inside], 'b.', markersize=1, label='Inside Circle') ax.plot(x[~inside], y[~inside], 'r.', markersize=1, label='Outside Circle') ax.add_patch(plt.Circle((0, 0), 1, color='black', fill=False)) ax.legend() plt.grid(True) plt.show() return pi_estimate # Try with different sizes for n in [100, 1000, 10000, 100000]: estimate_pi_circle(n) Visit: Colab","title":"2. Simulation Code"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-convergence-analysis","text":"import matplotlib.pyplot as plt def convergence_analysis_circle(max_points=100000, step=1000): estimates = [] x_vals = list(range(step, max_points + 1, step)) for n in x_vals: x = np.random.uniform(-1, 1, n) y = np.random.uniform(-1, 1, n) inside = x**2 + y**2 <= 1 pi_approx = 4 * np.sum(inside) / n estimates.append(pi_approx) plt.figure(figsize=(10, 5)) plt.plot(x_vals, estimates, label='Estimated \u03c0') plt.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0') plt.title(\"Convergence of \u03c0 Estimation using Circle Method\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() convergence_analysis_circle() Visit: Colab","title":"3. Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-animation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters n_points = 5000 # Total points step = 100 # Points per animation frame # Generate random points x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) r = x**2 + y**2 inside = r <= 1 # Set up the figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-1, 1) ax.set_ylim(-1, 1) ax.set_title(\"Estimating \u03c0 via Monte Carlo\") points_in, = ax.plot([], [], 'b.', markersize=1, label='Inside Circle') points_out, = ax.plot([], [], 'r.', markersize=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, fill=False, color='black') ax.add_artist(circle) ax.legend() # Animation update function def update(frame): idx = slice(0, step * (frame + 1)) points_in.set_data(x[idx][inside[idx]], y[idx][inside[idx]]) points_out.set_data(x[idx][~inside[idx]], y[idx][~inside[idx]]) current_pi = 4 * np.sum(inside[idx]) / len(x[idx]) ax.set_title(f\"Estimation of \u03c0: {current_pi:.5f} (n={len(x[idx])})\") return points_in, points_out frames = n_points // step ani = FuncAnimation(fig, update, frames=frames, interval=50, blit=True) plt.close() HTML(ani.to_jshtml()) Visit: Colab","title":"4. Animation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"PART 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"In Buffon's Needle experiment, we drop a needle of length \\(L\\) onto a plane with parallel lines spaced \\(d\\) apart. Let: \\(L\\) = length of needle \\(d\\) = distance between lines \\(L \\leq d\\) The probability \\(P\\) that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\Rightarrow \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: \\(N\\) = total number of drops \\(C\\) = number of crosses","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-code_1","text":"def simulate_buffon_needle(N=10000, L=1.0, d=2.0): assert L <= d, \"Needle length must be less than or equal to distance between lines\" # Random positions and angles theta = np.random.uniform(0, np.pi / 2, N) y = np.random.uniform(0, d / 2, N) crosses = y <= (L / 2) * np.sin(theta) C = np.sum(crosses) pi_estimate = (2 * L * N) / (C * d) if C > 0 else np.nan # Plot a few needles num_visual = 200 x_center = np.random.uniform(0, 10, num_visual) y_center = np.random.uniform(0, 10, num_visual) theta_visual = np.random.uniform(0, np.pi, num_visual) plt.figure(figsize=(10, 6)) for i in range(num_visual): x0 = x_center[i] - (L / 2) * np.cos(theta_visual[i]) y0 = y_center[i] - (L / 2) * np.sin(theta_visual[i]) x1 = x_center[i] + (L / 2) * np.cos(theta_visual[i]) y1 = y_center[i] + (L / 2) * np.sin(theta_visual[i]) color = 'blue' if np.floor(y0 / d) != np.floor(y1 / d) else 'gray' plt.plot([x0, x1], [y0, y1], color=color) for i in range(12): plt.axhline(i * d, color='black', linestyle='--', linewidth=0.5) plt.title(f\"Buffon's Needle Estimate of \u03c0 = {pi_estimate:.6f}\") plt.xlim(0, 10) plt.ylim(0, 10) plt.grid(True) plt.show() return pi_estimate simulate_buffon_needle() Visit: Colab","title":"2. Simulation Code"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-convergence-analysis_1","text":"def convergence_analysis_buffon(N_max=10000, step=500, L=1.0, d=2.0): estimates = [] x_vals = [] for n in range(step, N_max + 1, step): theta = np.random.uniform(0, np.pi / 2, n) y = np.random.uniform(0, d / 2, n) crosses = y <= (L / 2) * np.sin(theta) C = np.sum(crosses) if C == 0: estimates.append(np.nan) else: pi_est = (2 * L * n) / (C * d) estimates.append(pi_est) x_vals.append(n) plt.figure(figsize=(10, 5)) plt.plot(x_vals, estimates, label=\"Estimated \u03c0\") plt.axhline(np.pi, color='red', linestyle='--', label=\"True \u03c0\") plt.title(\"Convergence of \u03c0 Estimation using Buffon's Needle\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() convergence_analysis_buffon() Visit: Colab import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters N = 500 # total needles step = 20 # needles per frame L = 0.8 # length of needle d = 1.0 # line spacing # Generate random angles and positions theta = np.random.uniform(0, np.pi, N) y_center = np.random.uniform(0, d/2, N) # Compute endpoints of needles x0 = np.zeros(N) y0 = y_center x1 = L/2 * np.cos(theta) y1 = L/2 * np.sin(theta) # Check crossing condition crosses = y_center <= (L/2) * np.sin(theta) # Setup plot fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1, 1) ax.set_ylim(0, d) ax.set_aspect('equal') ax.set_title(\"Buffon's Needle Simulation\") ax.hlines([0, d], -1, 1, colors='k', linewidth=1) needle_lines = [] def update(frame): global needle_lines for line in needle_lines: line.remove() needle_lines = [] end = min(N, (frame+1)*step) for i in range(end): x_start = -x1[i] x_end = x1[i] y_start = y0[i] - y1[i] y_end = y0[i] + y1[i] color = 'r' if crosses[i] else 'b' needle = ax.plot([x_start, x_end], [y_start, y_end], color=color, linewidth=1) needle_lines.extend(needle) if np.sum(crosses[:end]) > 0: pi_est = (2 * L * end) / (d * np.sum(crosses[:end])) ax.set_title(f\"Buffon's Needle \u03c0 \u2248 {pi_est:.5f} (n={end})\") else: ax.set_title(\"Waiting for first cross...\") return needle_lines frames = N // step ani = FuncAnimation(fig, update, frames=frames, interval=200, blit=False) plt.close() HTML(ani.to_jshtml()) Visit: Colab","title":"3. Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-of-both-methods","text":"Method Accuracy (fast?) Simplicity Visualization Variance Circle Method Faster convergence Very easy Easy to plot Low to Medium Buffon's Needle Slower More complex Geometric High","title":"Comparison of Both Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary","text":"Circle-based method uses 2D geometry and is fast and simple. Buffon\u2019s Needle is elegant and connects probability to geometry but converges more slowly. Both methods illustrate how randomness and computation can estimate mathematical constants.","title":"Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Motivation The acceleration due to gravity \\(g\\) is a crucial constant in physics. A simple pendulum provides an elegant way to experimentally measure \\(g\\) , emphasizing: Oscillation-based measurement techniques Precision timing and measurement Uncertainty quantification Theoretical Derivation 1. Period of a Simple Pendulum For small angles \\(\\theta < 15^\\circ\\) , the motion of a simple pendulum approximates simple harmonic motion: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Where: \\(T\\) is the period of one oscillation \\(L\\) is the length of the pendulum \\(g\\) is the local gravitational acceleration 2. Solving for \\(g\\) \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Experimental Procedure Materials String (1\u20131.5 meters) Weight (keychain, coin bag, etc.) Stopwatch / Smartphone Ruler or tape measure Data Collection Measure pendulum length \\(L\\) with resolution \\(\\Delta L\\) , uncertainty = \\(\\frac{\\Delta L}{2}\\) Perform 10 measurements of time for 10 oscillations each: \\(t_1, t_2, ..., t_{10}\\) Calculate: Mean \\(\\bar{t}\\) Standard deviation \\(\\sigma\\) Period \\(T = \\frac{\\bar{t}}{10}\\) Uncertainty Analysis Uncertainty in Time: \\[ \\sigma_T = \\frac{\\sigma_{\\bar{t}}}{10} = \\frac{\\sigma}{10\\sqrt{n}} \\] Uncertainty in \\(g\\) : \\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\sigma_T}{T} \\right)^2 } \\] Python Code import numpy as np import matplotlib.pyplot as plt # Example time measurements (10 trials) t_measurements = np.array([20.1, 20.3, 20.2, 20.0, 20.4, 20.1, 20.2, 20.3, 20.2, 20.1]) # Calculate stats mean_t10 = np.mean(t_measurements) std_t10 = np.std(t_measurements, ddof=1) # Plot plt.figure(figsize=(8, 5)) plt.errorbar(range(1, 11), t_measurements, yerr=0.1, fmt='o', label='Measured Times') plt.axhline(mean_t10, color='red', linestyle='--', label=f'Mean: {mean_t10:.2f}s') plt.fill_between(range(1, 11), mean_t10 - std_t10, mean_t10 + std_t10, color='red', alpha=0.2, label='\u00b11 SD') plt.title(\"Measured Time for 10 Oscillations (with Error Bars)\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.show() Visit: Colab # Pendulum lengths from 0.2 m to 2.0 m L_vals = np.linspace(0.2, 2.0, 100) g = 9.81 # m/s\u00b2 T_vals = 2 * np.pi * np.sqrt(L_vals / g) # Plot plt.figure(figsize=(8, 5)) plt.plot(L_vals, T_vals, color='blue') plt.title(\"Pendulum Period vs. Length\") plt.xlabel(\"Length (m)\") plt.ylabel(\"Period (s)\") plt.grid(True) plt.show() Visit: Colab # Simulate periods with small timing errors L = 1.0 # fixed length T_sim = np.linspace(1.8, 2.2, 100) g_sim = 4 * np.pi**2 * L / T_sim**2 # Plot plt.figure(figsize=(8, 5)) plt.plot(T_sim, g_sim, label='Calculated g') plt.axhline(9.81, color='green', linestyle='--', label='True g') plt.title(\"Effect of Period Error on Calculated g\") plt.xlabel(\"Period (s)\") plt.ylabel(\"Calculated g (m/s\u00b2)\") plt.legend() plt.grid(True) plt.show() Visit: Colab import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Pendulum parameters L = 1.0 # length in meters theta0 = 0.2 # initial angle in radians (small angle) # Time array for animation (duration = 10 seconds at 30 FPS) t = np.linspace(0, 10, 300) omega = np.sqrt(9.81 / L) theta = theta0 * np.cos(omega * t) # Convert to x, y positions x = L * np.sin(theta) y = -L * np.cos(theta) # Set up the figure fig, ax = plt.subplots(figsize=(5, 5)) ax.set_xlim(-L - 0.2, L + 0.2) ax.set_ylim(-L - 0.2, 0.2) ax.set_aspect('equal') line, = ax.plot([], [], 'o-', lw=3) pivot = [0, 0] # Initialization def init(): line.set_data([], []) return line, # Animation function def update(i): line.set_data([pivot[0], x[i]], [pivot[1], y[i]]) return line, # Create animation ani = FuncAnimation(fig, update, frames=len(t), init_func=init, blit=True) plt.close() # Prevent duplicate static plot # Display in Colab HTML(ani.to_jshtml()) Visit: Colab Markdown Table Template ### Raw Data | Trial | Time for 10 Oscillations (s) | |-------|-------------------------------| | 1 | 20.1 | | 2 | 20.3 | | 3 | 20.2 | | 4 | 20.0 | | 5 | 20.4 | | 6 | 20.1 | | 7 | 20.2 | | 8 | 20.3 | | 9 | 20.2 | | 10 | 20.1 | ### Summary - Mean time for 10 oscillations: \\( \\bar{t} = 20.19 \\pm 0.12 \\) s - Period \\( T = 2.019 \\pm 0.012 \\) s - Pendulum length \\( L = 1.00 \\pm 0.005 \\) m - Calculated \\( g = 9.66 \\pm 0.11 \\, \\text{m/s}^2 \\) Discussion and Analysis 1. Comparison to Standard Value Measured \\(g\\) : \\~9.66 m/s\u00b2 Accepted \\(g\\) : 9.81 m/s\u00b2 Difference may stem from systematic timing error or measurement of \\(L\\) 2. Sources of Uncertainty Measurement resolution : Ruler error affects \\(L\\) Human reaction time : Affects timing measurements Angle of release : Larger angles introduce non-linear effects 3. Experimental Limitations Assumes no air resistance and massless string Assumes rigid pivot and no energy loss","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity \\(g\\) is a crucial constant in physics. A simple pendulum provides an elegant way to experimentally measure \\(g\\) , emphasizing: Oscillation-based measurement techniques Precision timing and measurement Uncertainty quantification","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#theoretical-derivation","text":"","title":"Theoretical Derivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-period-of-a-simple-pendulum","text":"For small angles \\(\\theta < 15^\\circ\\) , the motion of a simple pendulum approximates simple harmonic motion: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Where: \\(T\\) is the period of one oscillation \\(L\\) is the length of the pendulum \\(g\\) is the local gravitational acceleration","title":"1. Period of a Simple Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-solving-for-g","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"2. Solving for \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#experimental-procedure","text":"","title":"Experimental Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"String (1\u20131.5 meters) Weight (keychain, coin bag, etc.) Stopwatch / Smartphone Ruler or tape measure","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"Measure pendulum length \\(L\\) with resolution \\(\\Delta L\\) , uncertainty = \\(\\frac{\\Delta L}{2}\\) Perform 10 measurements of time for 10 oscillations each: \\(t_1, t_2, ..., t_{10}\\) Calculate: Mean \\(\\bar{t}\\) Standard deviation \\(\\sigma\\) Period \\(T = \\frac{\\bar{t}}{10}\\)","title":"Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-analysis","text":"","title":"Uncertainty Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-time","text":"\\[ \\sigma_T = \\frac{\\sigma_{\\bar{t}}}{10} = \\frac{\\sigma}{10\\sqrt{n}} \\]","title":"Uncertainty in Time:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-g","text":"\\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\sigma_T}{T} \\right)^2 } \\]","title":"Uncertainty in \\(g\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Example time measurements (10 trials) t_measurements = np.array([20.1, 20.3, 20.2, 20.0, 20.4, 20.1, 20.2, 20.3, 20.2, 20.1]) # Calculate stats mean_t10 = np.mean(t_measurements) std_t10 = np.std(t_measurements, ddof=1) # Plot plt.figure(figsize=(8, 5)) plt.errorbar(range(1, 11), t_measurements, yerr=0.1, fmt='o', label='Measured Times') plt.axhline(mean_t10, color='red', linestyle='--', label=f'Mean: {mean_t10:.2f}s') plt.fill_between(range(1, 11), mean_t10 - std_t10, mean_t10 + std_t10, color='red', alpha=0.2, label='\u00b11 SD') plt.title(\"Measured Time for 10 Oscillations (with Error Bars)\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.show()","title":"Python Code"},{"location":"1%20Physics/7%20Measurements/Problem_1/#visit-colab","text":"# Pendulum lengths from 0.2 m to 2.0 m L_vals = np.linspace(0.2, 2.0, 100) g = 9.81 # m/s\u00b2 T_vals = 2 * np.pi * np.sqrt(L_vals / g) # Plot plt.figure(figsize=(8, 5)) plt.plot(L_vals, T_vals, color='blue') plt.title(\"Pendulum Period vs. Length\") plt.xlabel(\"Length (m)\") plt.ylabel(\"Period (s)\") plt.grid(True) plt.show() Visit: Colab # Simulate periods with small timing errors L = 1.0 # fixed length T_sim = np.linspace(1.8, 2.2, 100) g_sim = 4 * np.pi**2 * L / T_sim**2 # Plot plt.figure(figsize=(8, 5)) plt.plot(T_sim, g_sim, label='Calculated g') plt.axhline(9.81, color='green', linestyle='--', label='True g') plt.title(\"Effect of Period Error on Calculated g\") plt.xlabel(\"Period (s)\") plt.ylabel(\"Calculated g (m/s\u00b2)\") plt.legend() plt.grid(True) plt.show() Visit: Colab import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Pendulum parameters L = 1.0 # length in meters theta0 = 0.2 # initial angle in radians (small angle) # Time array for animation (duration = 10 seconds at 30 FPS) t = np.linspace(0, 10, 300) omega = np.sqrt(9.81 / L) theta = theta0 * np.cos(omega * t) # Convert to x, y positions x = L * np.sin(theta) y = -L * np.cos(theta) # Set up the figure fig, ax = plt.subplots(figsize=(5, 5)) ax.set_xlim(-L - 0.2, L + 0.2) ax.set_ylim(-L - 0.2, 0.2) ax.set_aspect('equal') line, = ax.plot([], [], 'o-', lw=3) pivot = [0, 0] # Initialization def init(): line.set_data([], []) return line, # Animation function def update(i): line.set_data([pivot[0], x[i]], [pivot[1], y[i]]) return line, # Create animation ani = FuncAnimation(fig, update, frames=len(t), init_func=init, blit=True) plt.close() # Prevent duplicate static plot # Display in Colab HTML(ani.to_jshtml())","title":"Visit: Colab"},{"location":"1%20Physics/7%20Measurements/Problem_1/#visit-colab_1","text":"","title":"Visit: Colab"},{"location":"1%20Physics/7%20Measurements/Problem_1/#markdown-table-template","text":"### Raw Data | Trial | Time for 10 Oscillations (s) | |-------|-------------------------------| | 1 | 20.1 | | 2 | 20.3 | | 3 | 20.2 | | 4 | 20.0 | | 5 | 20.4 | | 6 | 20.1 | | 7 | 20.2 | | 8 | 20.3 | | 9 | 20.2 | | 10 | 20.1 | ### Summary - Mean time for 10 oscillations: \\( \\bar{t} = 20.19 \\pm 0.12 \\) s - Period \\( T = 2.019 \\pm 0.012 \\) s - Pendulum length \\( L = 1.00 \\pm 0.005 \\) m - Calculated \\( g = 9.66 \\pm 0.11 \\, \\text{m/s}^2 \\)","title":"Markdown Table Template"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion-and-analysis","text":"","title":"Discussion and Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-comparison-to-standard-value","text":"Measured \\(g\\) : \\~9.66 m/s\u00b2 Accepted \\(g\\) : 9.81 m/s\u00b2 Difference may stem from systematic timing error or measurement of \\(L\\)","title":"1. Comparison to Standard Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-sources-of-uncertainty","text":"Measurement resolution : Ruler error affects \\(L\\) Human reaction time : Affects timing measurements Angle of release : Larger angles introduce non-linear effects","title":"2. Sources of Uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-experimental-limitations","text":"Assumes no air resistance and massless string Assumes rigid pivot and no energy loss","title":"3. Experimental Limitations"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}