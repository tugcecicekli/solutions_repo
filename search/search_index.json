{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion is a fundamental topic in mechanics that offers a clean yet rich context for understanding the application of differential equations, Newton's laws, and kinematic principles. The central goal is to investigate how the horizontal range of a projectile depends on the angle of launch. Though the setup appears straightforward, the analysis reveals intricate dependencies on initial conditions and physical parameters. Understanding projectile motion is essential in a variety of fields\u2014from sports and civil engineering to space science and military applications. By starting from first principles and layering in simulation, this project provides both theoretical insight and computational practice. 1. Theoretical Foundation: Differential Equations Assumptions: The motion is in two dimensions. Air resistance is neglected. Gravity acts uniformly downward. Launch and landing heights are equal. We begin with Newton's second law: \\(\\vec{F} = m\\vec{a} \\Rightarrow \\frac{d^2 \\vec{r}}{dt^2} = \\vec{a}\\) Decomposing motion into x (horizontal) and y (vertical) directions: Horizontal Motion: \\(\\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) t\\) Vertical Motion: \\(\\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2\\) Time of Flight: Set \\(y(t) = 0\\) to find when the projectile lands: \\(t = \\frac{2v_0 \\sin(\\theta)}{g}\\) Horizontal Range: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) This is the key result showing how range depends on initial velocity, gravity, and angle. 2. Simulation: Python Code and Visualizations Range vs. Angle Plot import numpy as np import matplotlib.pyplot as plt v0 = 30 # initial velocity in m/s g = 9.81 # gravitational acceleration in m/s^2 angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Calculate range R = (v0**2 * np.sin(2 * angles_rad)) / g # Plot range vs angle plt.figure(figsize=(10, 6)) plt.plot(angles, R, color='royalblue') plt.axvline(45, color='red', linestyle='--', label='\\u03b8 = 45\\xb0 (Max Range)') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show() Output: Visit: Colab Multiple Trajectories for Different Angles # Time vector angles_deg = [15, 30, 45, 60, 75] colors = ['blue', 'green', 'orange', 'purple', 'brown'] plt.figure(figsize=(10, 6)) for angle, color in zip(angles_deg, colors): theta = np.radians(angle) t_flight = 2 * v0 * np.sin(theta) / g t_vals = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t_vals y = v0 * np.sin(theta) * t_vals - 0.5 * g * t_vals**2 plt.plot(x, y, label=f\"{angle}\u00b0\", color=color) plt.title(\"Projectile Trajectories for Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.show() Output: Visit: Colab Animated Projectile Motion import matplotlib.animation as animation fig, ax = plt.subplots(figsize=(8, 5)) angle = np.radians(45) t_flight = 2 * v0 * np.sin(angle) / g t_vals = np.linspace(0, t_flight, 300) x_vals = v0 * np.cos(angle) * t_vals y_vals = v0 * np.sin(angle) * t_vals - 0.5 * g * t_vals**2 line, = ax.plot([], [], 'bo') ax.set_xlim(0, max(x_vals)) ax.set_ylim(0, max(y_vals)*1.1) ax.set_xlabel('Horizontal Distance (m)') ax.set_ylabel('Vertical Height (m)') ax.set_title('Animated Projectile Motion') # Initialization function def init(): line.set_data([], []) return line, # Animation function def animate(i): line.set_data(x_vals[i], y_vals[i]) return line, ani = animation.FuncAnimation(fig, animate, frames=len(t_vals), init_func=init, interval=20, blit=True) plt.show() Visit: Colab Range vs. Angle for Different Velocities velocities = [10, 20, 30, 40] plt.figure(figsize=(10, 6)) for v in velocities: R = (v**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, R, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Angle for Various Initial Velocities') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.legend() plt.grid(True) plt.show() Visit Colab Output: Curves rising in height as initial velocity increases, but always peaking at 45\u00b0. 3. Practical Applications Sports : Optimize kicking or throwing angles. Engineering : Design water fountains, civil projectiles, or robotic arm paths. Aerospace : Launch trajectories under different gravitational conditions. Defense : Missile and artillery trajectory planning. 4. Extensions and Real-World Models Air Resistance Introducing drag results in non-linear differential equations. For example: \\(m \\frac{d^2x}{dt^2} = -kv_x, \\quad m \\frac{d^2y}{dt^2} = -mg - kv_y\\) where \\(k\\) is the drag coefficient. This requires numerical solving methods (like Runge-Kutta) for simulation. Python Simulation with Air Resistance (Euler Method) def simulate_drag(v0, theta_deg, dt=0.01, k=0.1): theta = np.radians(theta_deg) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = 0, 0 positions_x, positions_y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions_x.append(x) positions_y.append(y) return positions_x, positions_y plt.figure(figsize=(10, 6)) for angle in [30, 45, 60]: x_vals, y_vals = simulate_drag(30, angle) plt.plot(x_vals, y_vals, label=f\"With drag, {angle}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.title(\"Projectile Motion with Air Resistance\") plt.legend() plt.grid(True) plt.show() Visit Colab Uneven Terrain and Variable Gravity Other extensions include: - Launching from/landing on slopes (geometry needed) - Varying \\(g\\) with altitude or planetary conditions Conclusion Starting from Newton's laws, we built a full mathematical model of projectile motion using differential equations. We derived the range formula and implemented visual simulations to understand how the angle of projection affects range. The model, while idealized, provides deep insight and serves as a powerful foundation for more complex analyses. With Python, we've created tools to simulate, visualize, and animate this system dynamically. Extensions include modeling drag and simulating on non-flat terrains\u2014perfect for bridging theory and real-world applications.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is a fundamental topic in mechanics that offers a clean yet rich context for understanding the application of differential equations, Newton's laws, and kinematic principles. The central goal is to investigate how the horizontal range of a projectile depends on the angle of launch. Though the setup appears straightforward, the analysis reveals intricate dependencies on initial conditions and physical parameters. Understanding projectile motion is essential in a variety of fields\u2014from sports and civil engineering to space science and military applications. By starting from first principles and layering in simulation, this project provides both theoretical insight and computational practice.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation-differential-equations","text":"","title":"1. Theoretical Foundation: Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#assumptions","text":"The motion is in two dimensions. Air resistance is neglected. Gravity acts uniformly downward. Launch and landing heights are equal. We begin with Newton's second law: \\(\\vec{F} = m\\vec{a} \\Rightarrow \\frac{d^2 \\vec{r}}{dt^2} = \\vec{a}\\) Decomposing motion into x (horizontal) and y (vertical) directions:","title":"Assumptions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"\\(\\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) t\\)","title":"Horizontal Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"\\(\\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2\\)","title":"Vertical Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Set \\(y(t) = 0\\) to find when the projectile lands: \\(t = \\frac{2v_0 \\sin(\\theta)}{g}\\)","title":"Time of Flight:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"\\(R = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) This is the key result showing how range depends on initial velocity, gravity, and angle.","title":"Horizontal Range:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-simulation-python-code-and-visualizations","text":"","title":"2. Simulation: Python Code and Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-plot","text":"import numpy as np import matplotlib.pyplot as plt v0 = 30 # initial velocity in m/s g = 9.81 # gravitational acceleration in m/s^2 angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Calculate range R = (v0**2 * np.sin(2 * angles_rad)) / g # Plot range vs angle plt.figure(figsize=(10, 6)) plt.plot(angles, R, color='royalblue') plt.axvline(45, color='red', linestyle='--', label='\\u03b8 = 45\\xb0 (Max Range)') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"Range vs. Angle Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output","text":"Visit: Colab","title":"Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#multiple-trajectories-for-different-angles","text":"# Time vector angles_deg = [15, 30, 45, 60, 75] colors = ['blue', 'green', 'orange', 'purple', 'brown'] plt.figure(figsize=(10, 6)) for angle, color in zip(angles_deg, colors): theta = np.radians(angle) t_flight = 2 * v0 * np.sin(theta) / g t_vals = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t_vals y = v0 * np.sin(theta) * t_vals - 0.5 * g * t_vals**2 plt.plot(x, y, label=f\"{angle}\u00b0\", color=color) plt.title(\"Projectile Trajectories for Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.show()","title":"Multiple Trajectories for Different Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output_1","text":"Visit: Colab","title":"Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#animated-projectile-motion","text":"import matplotlib.animation as animation fig, ax = plt.subplots(figsize=(8, 5)) angle = np.radians(45) t_flight = 2 * v0 * np.sin(angle) / g t_vals = np.linspace(0, t_flight, 300) x_vals = v0 * np.cos(angle) * t_vals y_vals = v0 * np.sin(angle) * t_vals - 0.5 * g * t_vals**2 line, = ax.plot([], [], 'bo') ax.set_xlim(0, max(x_vals)) ax.set_ylim(0, max(y_vals)*1.1) ax.set_xlabel('Horizontal Distance (m)') ax.set_ylabel('Vertical Height (m)') ax.set_title('Animated Projectile Motion') # Initialization function def init(): line.set_data([], []) return line, # Animation function def animate(i): line.set_data(x_vals[i], y_vals[i]) return line, ani = animation.FuncAnimation(fig, animate, frames=len(t_vals), init_func=init, interval=20, blit=True) plt.show()","title":"Animated Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visitcolab","text":"","title":"Visit:Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-for-different-velocities","text":"velocities = [10, 20, 30, 40] plt.figure(figsize=(10, 6)) for v in velocities: R = (v**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, R, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Angle for Various Initial Velocities') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.legend() plt.grid(True) plt.show() Visit Colab","title":"Range vs. Angle for Different Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output_2","text":"Curves rising in height as initial velocity increases, but always peaking at 45\u00b0.","title":"Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimize kicking or throwing angles. Engineering : Design water fountains, civil projectiles, or robotic arm paths. Aerospace : Launch trajectories under different gravitational conditions. Defense : Missile and artillery trajectory planning.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-extensions-and-real-world-models","text":"","title":"4. Extensions and Real-World Models"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#air-resistance","text":"Introducing drag results in non-linear differential equations. For example: \\(m \\frac{d^2x}{dt^2} = -kv_x, \\quad m \\frac{d^2y}{dt^2} = -mg - kv_y\\) where \\(k\\) is the drag coefficient. This requires numerical solving methods (like Runge-Kutta) for simulation.","title":"Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation-with-air-resistance-euler-method","text":"def simulate_drag(v0, theta_deg, dt=0.01, k=0.1): theta = np.radians(theta_deg) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = 0, 0 positions_x, positions_y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions_x.append(x) positions_y.append(y) return positions_x, positions_y plt.figure(figsize=(10, 6)) for angle in [30, 45, 60]: x_vals, y_vals = simulate_drag(30, angle) plt.plot(x_vals, y_vals, label=f\"With drag, {angle}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.title(\"Projectile Motion with Air Resistance\") plt.legend() plt.grid(True) plt.show() Visit Colab","title":"Python Simulation with Air Resistance (Euler Method)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#uneven-terrain-and-variable-gravity","text":"Other extensions include: - Launching from/landing on slopes (geometry needed) - Varying \\(g\\) with altitude or planetary conditions","title":"Uneven Terrain and Variable Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Starting from Newton's laws, we built a full mathematical model of projectile motion using differential equations. We derived the range formula and implemented visual simulations to understand how the angle of projection affects range. The model, while idealized, provides deep insight and serves as a powerful foundation for more complex analyses. With Python, we've created tools to simulate, visualize, and animate this system dynamically. Extensions include modeling drag and simulating on non-flat terrains\u2014perfect for bridging theory and real-world applications.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The pendulum is a powerful model in physics. From simple harmonic motion to chaos, it demonstrates how small changes \u2014 damping and forcing \u2014 result in complex behavior. This project investigates: Simple Pendulum Damped Pendulum Forced Damped Pendulum 1. Differential Equations Simple Pendulum \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = 0\\] For small angles: \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\theta = 0, \\quad \\omega_0 = \\sqrt{\\frac{g}{L}}\\] Damped Pendulum \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0\\] Forced Pendulum \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\] Where: \\(\\theta(t)\\) : angular displacement (in radians) \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) : natural frequency of the pendulum \\(A\\) : amplitude of the external driving force (torque per unit mass and length) \\(\\omega\\) : angular frequency of the driving force \\(t\\) : time \\(g\\) : gravitational acceleration \\(L\\) : length of the pendulum Forced Damped Pendulum \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\] 2. Visualizing the Simple Pendulum (Small Angle Approximation) import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 t = np.linspace(0, 10, 1000) theta = theta0 * np.cos(omega0 * t) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Simple Pendulum (Small Angle Approximation)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab 3. Visualizing the Damped Pendulum # Damped system using RK4 import numpy as np import matplotlib.pyplot as plt dt = 0.01 t = np.arange(0, 20, dt) b = 0.3 # damping theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 # Define omega0 here omega0 = 1.0 # You can change this value to the desired natural frequency def rk4_damped(theta, omega, t, dt, b, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * theta]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_damped(theta[i-1], omega[i-1], t[i-1], dt, b, omega0) plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab 4. Visualizing the Forced Pendulum import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 b = 0.0 # No damping A = 1.2 # Forcing amplitude omega_d = 2/3 # Driving frequency dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) # RK4 integration for the forced pendulum def rk4_step(theta, omega, t, dt): def f(t, y): theta, omega = y dtheta = omega domega = -omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 # Simulation theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = theta0 omega[0] = omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt) # Plotting fig, axs = plt.subplots(1, 2, figsize=(12, 4)) # Time Series axs[0].plot(t, theta, color='darkorange') axs[0].set_title(\"Forced Pendulum (No Damping) - Time Series\") axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(\"Angle \u03b8 (rad)\") axs[0].grid(True) # Phase Portrait axs[1].plot(theta, omega, color='orangered') axs[1].set_title(\"Forced Pendulum (No Damping) - Phase Portrait\") axs[1].set_xlabel(\"\u03b8 (rad)\") axs[1].set_ylabel(\"\u03c9 (rad/s)\") axs[1].grid(True) plt.tight_layout() plt.show() Visit: Colab 5. Visualizing the Forced Damped Pendulum # Forced Damped Pendulum Simulation import numpy as np import matplotlib.pyplot as plt # Parameters omega0 = 2 dt = 0.01 t = np.arange(0, 10, dt) A = 1.2 omega_d = 2/3 b = 0.5 theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 def rk4_forced(theta, omega, t, dt, b, A, omega_d, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t)]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_forced(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, omega0) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab 6. Animation of the Forced Damped Pendulum import matplotlib.animation as animation from IPython.display import HTML import numpy as np # This was missing # Assuming L represents the length of the pendulum, set it to a reasonable value L = 1 # You can adjust this value as needed x_vals = L * np.sin(theta) y_vals = -L * np.cos(theta) fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2, 1.2) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.grid() line, = ax.plot([], [], 'o-', lw=2) trail, = ax.plot([], [], '-', lw=0.5) xdata, ydata = [], [] def init(): line.set_data([], []) trail.set_data([], []) return line, trail def animate(i): x, y = x_vals[i], y_vals[i] xdata.append(x) ydata.append(y) if len(xdata) > 100: xdata.pop(0) ydata.pop(0) line.set_data([0, x], [0, y]) trail.set_data(xdata, ydata) return line, trail ani = animation.FuncAnimation(fig, animate, frames=range(0, len(x_vals), 5), init_func=init, blit=True, interval=20) plt.close() HTML(ani.to_jshtml()) Visit: Colab import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 dt = 0.01 t_max = 20 t = np.arange(0, t_max, dt) # Unified RK4 method def rk4_step(theta, omega, t, dt, b=0, A=0, omega_d=0, use_sin=True): def f(t, y): theta, omega = y dtheta = omega if use_sin: domega = -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) else: domega = -b * omega - omega0**2 * theta + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 def simulate(b=0, A=0, omega_d=0, use_sin=True): theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0], omega[0] = theta0, omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, use_sin) return theta, omega # Simulate all three theta1, omega1 = simulate(b=0, A=0, use_sin=False) # Simple theta2, omega2 = simulate(b=0.2, A=0, use_sin=False) # Damped theta3, omega3 = simulate(b=0.5, A=1.2, omega_d=2/3, use_sin=True) # Forced # Plot layout fig, axs = plt.subplots(3, 2, figsize=(12, 10)) titles = [\"1) Simple Pendulum\", \"2) Damped Pendulum\", \"3) Forced Pendulum\"] colors = ['red', 'blue', 'teal'] # Time Series axs[0, 0].plot(t, theta1, color=colors[0]) axs[1, 0].plot(t, theta2, color=colors[1]) axs[2, 0].plot(t, theta3, color=colors[2]) for i in range(3): axs[i, 0].set_title(\"Time Series\") axs[i, 0].set_xlabel(\"Time (s)\") axs[i, 0].set_ylabel(\"\u03b8 (rad)\") axs[i, 0].grid(True) axs[i, 0].annotate(titles[i], xy=(0.95, 0.85), xycoords='axes fraction', ha='right', fontsize=11, color=colors[i], weight='bold') # Phase Portraits axs[0, 1].plot(theta1, omega1, color=colors[0]) axs[1, 1].plot(theta2, omega2, color=colors[1]) axs[2, 1].plot(theta3, omega3, color=colors[2]) for i in range(3): axs[i, 1].set_title(\"Phase Portrait\") axs[i, 1].set_xlabel(\"\u03b8 (rad)\") axs[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axs[i, 1].grid(True) plt.tight_layout() plt.show() Visit: Colab 7. Extensions and Advanced Explorations Phase Portraits & Poincar\u00e9 Sections : Reveal geometry of motion and transitions to chaos. Bifurcation Diagrams : Vary forcing amplitude \\(A\\) or frequency \\(\\omega\\) and plot long-term values. Energy Analysis : Study how energy is gained/lost under forcing and damping. Lyapunov Exponents : Quantify sensitivity to initial conditions (chaos). Double Pendulum : A 2-link pendulum introduces deeper chaos with no external force. Planetary Gravity : Modify \\(g\\) to simulate behavior on Mars, Moon, etc. 8. Conclusion This project comprehensively examined pendulum dynamics in three stages: Variant Damping Forcing Behavior Simple Pendulum \u2718 \u2718 Periodic Damped Pendulum \u2714 \u2718 Decaying oscillations Forced Damped \u2714 \u2714 Periodic / Quasiperiodic / Chaotic We: - Derived differential equations - Simulated each case using Runge-Kutta - Visualized the systems with graphs and animations - Proposed extensions into bifurcations, chaos, and energy studies The forced damped pendulum, though conceptually simple, becomes a gateway into the study of nonlinear systems and chaos \u2014 illustrating how deterministic rules can yield unpredictable motion.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The pendulum is a powerful model in physics. From simple harmonic motion to chaos, it demonstrates how small changes \u2014 damping and forcing \u2014 result in complex behavior. This project investigates: Simple Pendulum Damped Pendulum Forced Damped Pendulum","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-differential-equations","text":"","title":"1. Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simple-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = 0\\] For small angles: \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\theta = 0, \\quad \\omega_0 = \\sqrt{\\frac{g}{L}}\\]","title":"Simple Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damped-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0\\]","title":"Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\] Where: \\(\\theta(t)\\) : angular displacement (in radians) \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) : natural frequency of the pendulum \\(A\\) : amplitude of the external driving force (torque per unit mass and length) \\(\\omega\\) : angular frequency of the driving force \\(t\\) : time \\(g\\) : gravitational acceleration \\(L\\) : length of the pendulum","title":"Forced Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\]","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-visualizing-the-simple-pendulum-small-angle-approximation","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 t = np.linspace(0, 10, 1000) theta = theta0 * np.cos(omega0 * t) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Simple Pendulum (Small Angle Approximation)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab","title":"2. Visualizing the Simple Pendulum (Small Angle Approximation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-visualizing-the-damped-pendulum","text":"# Damped system using RK4 import numpy as np import matplotlib.pyplot as plt dt = 0.01 t = np.arange(0, 20, dt) b = 0.3 # damping theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 # Define omega0 here omega0 = 1.0 # You can change this value to the desired natural frequency def rk4_damped(theta, omega, t, dt, b, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * theta]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_damped(theta[i-1], omega[i-1], t[i-1], dt, b, omega0) plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab","title":"3. Visualizing the Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-visualizing-the-forced-pendulum","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 b = 0.0 # No damping A = 1.2 # Forcing amplitude omega_d = 2/3 # Driving frequency dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) # RK4 integration for the forced pendulum def rk4_step(theta, omega, t, dt): def f(t, y): theta, omega = y dtheta = omega domega = -omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 # Simulation theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = theta0 omega[0] = omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt) # Plotting fig, axs = plt.subplots(1, 2, figsize=(12, 4)) # Time Series axs[0].plot(t, theta, color='darkorange') axs[0].set_title(\"Forced Pendulum (No Damping) - Time Series\") axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(\"Angle \u03b8 (rad)\") axs[0].grid(True) # Phase Portrait axs[1].plot(theta, omega, color='orangered') axs[1].set_title(\"Forced Pendulum (No Damping) - Phase Portrait\") axs[1].set_xlabel(\"\u03b8 (rad)\") axs[1].set_ylabel(\"\u03c9 (rad/s)\") axs[1].grid(True) plt.tight_layout() plt.show() Visit: Colab","title":"4. Visualizing the Forced Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-visualizing-the-forced-damped-pendulum","text":"# Forced Damped Pendulum Simulation import numpy as np import matplotlib.pyplot as plt # Parameters omega0 = 2 dt = 0.01 t = np.arange(0, 10, dt) A = 1.2 omega_d = 2/3 b = 0.5 theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 def rk4_forced(theta, omega, t, dt, b, A, omega_d, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t)]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_forced(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, omega0) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab","title":"5. Visualizing the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-animation-of-the-forced-damped-pendulum","text":"import matplotlib.animation as animation from IPython.display import HTML import numpy as np # This was missing # Assuming L represents the length of the pendulum, set it to a reasonable value L = 1 # You can adjust this value as needed x_vals = L * np.sin(theta) y_vals = -L * np.cos(theta) fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2, 1.2) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.grid() line, = ax.plot([], [], 'o-', lw=2) trail, = ax.plot([], [], '-', lw=0.5) xdata, ydata = [], [] def init(): line.set_data([], []) trail.set_data([], []) return line, trail def animate(i): x, y = x_vals[i], y_vals[i] xdata.append(x) ydata.append(y) if len(xdata) > 100: xdata.pop(0) ydata.pop(0) line.set_data([0, x], [0, y]) trail.set_data(xdata, ydata) return line, trail ani = animation.FuncAnimation(fig, animate, frames=range(0, len(x_vals), 5), init_func=init, blit=True, interval=20) plt.close() HTML(ani.to_jshtml())","title":"6. Animation of the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visit-colab","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 dt = 0.01 t_max = 20 t = np.arange(0, t_max, dt) # Unified RK4 method def rk4_step(theta, omega, t, dt, b=0, A=0, omega_d=0, use_sin=True): def f(t, y): theta, omega = y dtheta = omega if use_sin: domega = -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) else: domega = -b * omega - omega0**2 * theta + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 def simulate(b=0, A=0, omega_d=0, use_sin=True): theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0], omega[0] = theta0, omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, use_sin) return theta, omega # Simulate all three theta1, omega1 = simulate(b=0, A=0, use_sin=False) # Simple theta2, omega2 = simulate(b=0.2, A=0, use_sin=False) # Damped theta3, omega3 = simulate(b=0.5, A=1.2, omega_d=2/3, use_sin=True) # Forced # Plot layout fig, axs = plt.subplots(3, 2, figsize=(12, 10)) titles = [\"1) Simple Pendulum\", \"2) Damped Pendulum\", \"3) Forced Pendulum\"] colors = ['red', 'blue', 'teal'] # Time Series axs[0, 0].plot(t, theta1, color=colors[0]) axs[1, 0].plot(t, theta2, color=colors[1]) axs[2, 0].plot(t, theta3, color=colors[2]) for i in range(3): axs[i, 0].set_title(\"Time Series\") axs[i, 0].set_xlabel(\"Time (s)\") axs[i, 0].set_ylabel(\"\u03b8 (rad)\") axs[i, 0].grid(True) axs[i, 0].annotate(titles[i], xy=(0.95, 0.85), xycoords='axes fraction', ha='right', fontsize=11, color=colors[i], weight='bold') # Phase Portraits axs[0, 1].plot(theta1, omega1, color=colors[0]) axs[1, 1].plot(theta2, omega2, color=colors[1]) axs[2, 1].plot(theta3, omega3, color=colors[2]) for i in range(3): axs[i, 1].set_title(\"Phase Portrait\") axs[i, 1].set_xlabel(\"\u03b8 (rad)\") axs[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axs[i, 1].grid(True) plt.tight_layout() plt.show() Visit: Colab","title":"Visit: Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-extensions-and-advanced-explorations","text":"Phase Portraits & Poincar\u00e9 Sections : Reveal geometry of motion and transitions to chaos. Bifurcation Diagrams : Vary forcing amplitude \\(A\\) or frequency \\(\\omega\\) and plot long-term values. Energy Analysis : Study how energy is gained/lost under forcing and damping. Lyapunov Exponents : Quantify sensitivity to initial conditions (chaos). Double Pendulum : A 2-link pendulum introduces deeper chaos with no external force. Planetary Gravity : Modify \\(g\\) to simulate behavior on Mars, Moon, etc.","title":"7. Extensions and Advanced Explorations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#8-conclusion","text":"This project comprehensively examined pendulum dynamics in three stages: Variant Damping Forcing Behavior Simple Pendulum \u2718 \u2718 Periodic Damped Pendulum \u2714 \u2718 Decaying oscillations Forced Damped \u2714 \u2714 Periodic / Quasiperiodic / Chaotic We: - Derived differential equations - Simulated each case using Runge-Kutta - Visualized the systems with graphs and animations - Proposed extensions into bifurcations, chaos, and energy studies The forced damped pendulum, though conceptually simple, becomes a gateway into the study of nonlinear systems and chaos \u2014 illustrating how deterministic rules can yield unpredictable motion.","title":"8. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The elegant relationship between the square of the orbital period (T) and the cube of the orbital radius (r) for circular orbits, known as Kepler\u2019s Third Law , reveals deep insights into gravitational interactions. This project aims to derive this law starting from Newtonian mechanics and differential equations, explore its real-world implications, and validate it through simulations and animations. Kepler\u2019s Third Law reveals a fundamental relationship in orbital mechanics: \\[T^2 \\propto r^3\\] This law connects the period of revolution \\(T\\) of a planet (or satellite) with the radius \\(r\\) of its circular orbit. It's a powerful tool used in celestial mechanics, satellite design, and calculating masses of celestial bodies. Theoretical Derivation using Newtonian Mechanics Step 1: Gravitational Force Newton\u2019s Law of Gravitation \\[F_g = \\frac{G M m}{r^2}\\] Step 2: Centripetal Force for Circular Orbits \\[F_c = \\frac{m v^2}{r}\\] Step 3: Equating Forces \\[\\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\] Step 4: Express Orbital Period \\[T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2}\\] Substitute \\(v^2\\) : \\[T^2 = \\frac{4\\pi^2 r^2}{\\frac{G M}{r}} = \\frac{4\\pi^2 r^3}{G M}\\] Final Form: \\[T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\Rightarrow T^2 \\propto r^3\\] Theoretical Analysis via Differential Equations Newton\u2019s Law of Universal Gravitation Gravitational force between two bodies of mass \\(M\\) (e.g., Earth) and \\(m\\) (e.g., satellite) is: \\[F = \\frac{G M m}{r^2}\\] Circular Motion Requirement For an object to stay in circular orbit, this gravitational force must equal the centripetal force: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\] Derivation Using Differential Equations The radial acceleration for a mass \\(m\\) in circular motion is: \\[\\vec{a} = \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M}{r^2} \\hat{r}\\] If the motion is constrained to a circular orbit, the position vector is: \\[\\vec{r}(t) = r (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j})\\] Differentiating twice gives: \\[\\frac{d^2 \\vec{r}}{dt^2} = -r \\omega^2 (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j}) = -\\omega^2 \\vec{r}\\] From Newton\u2019s second law: \\[m \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M m}{r^2} \\hat{r} \\Rightarrow -m \\omega^2 \\vec{r} = -\\frac{G M m}{r^2} \\hat{r}\\] Solving: \\[\\omega^2 = \\frac{G M}{r^3} \\Rightarrow T^2 = \\left( \\frac{2\\pi}{\\omega} \\right)^2 = \\frac{4\\pi^2 r^3}{G M}\\] This is Kepler\u2019s Third Law for circular orbits. Real-World Examples Moon's Orbit Around Earth Radius: \\(r \\approx 3.84 \\times 10^8\\) m Period: \\(T \\approx 27.3\\) days Verify Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\) Planets in the Solar System Planet Orbital Radius (AU) Period (years) Mercury 0.39 0.24 Earth 1.00 1.00 Jupiter 5.20 11.86 \\[\\frac{T^2}{r^3} \\approx \\text{constant}\\] import matplotlib.pyplot as plt import numpy as np # Sample data (replace with your actual data) radius = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.54]) # AU period = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Calculate T^2 and R^3 T_squared = period**2 R_cubed = radius**3 # Create the plot plt.figure(figsize=(8, 6)) plt.scatter(R_cubed, T_squared, label='Data Points') # Create the scatter plot # Add a best fit line (linear regression) coefficients = np.polyfit(R_cubed, T_squared, 1) polynomial = np.poly1d(coefficients) R_cubed_fit = np.linspace(min(R_cubed), max(R_cubed), 100) plt.plot(R_cubed_fit, polynomial(R_cubed_fit), color='red', label='Best Fit Line') # Add labels and title plt.xlabel(r'$R^3$ (AU$^3$)') plt.ylabel(r'$T^2$ (years$^2$)') plt.title('Orbital Period vs. Radius (Kepler\\'s Third Law)') plt.grid(True) # Add grid for better readability plt.legend() # Calculate and print the slope slope = coefficients[0] print(f\"Slope of the best-fit line: {slope:.2f}\") # Add text annotation showing the slope on the plot. plt.annotate(f\"Slope: {slope:.2f}\", xy=(0.65 * max(R_cubed), 0.85 * max(T_squared)), fontsize=12) # Show the plot plt.show() Visit: Colab Verifying Kepler\u2019s Law !pip install ace_tools # Install the required 'ace_tools' module import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns # Orbital data for planets (radius in AU, period in years) planets = { \"Mercury\": {\"r_AU\": 0.39, \"T_years\": 0.240846}, \"Venus\": {\"r_AU\": 0.723, \"T_years\": 0.615}, \"Earth\": {\"r_AU\": 1.000, \"T_years\": 1.000}, \"Mars\": {\"r_AU\": 1.524, \"T_years\": 1.881} } # Convert to arrays names = list(planets.keys()) r_AU = np.array([planets[p][\"r_AU\"] for p in names]) T_years = np.array([planets[p][\"T_years\"] for p in names]) # Calculate T^2 and r^3 T_squared = T_years**2 r_cubed = r_AU**3 # Create a DataFrame for visualization df = pd.DataFrame({ \"Planet\": names, \"r (AU)\": r_AU, \"T (years)\": T_years, \"r^3 (AU^3)\": r_cubed, \"T^2 (years^2)\": T_squared }) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 6)) sns.scatterplot(x=r_cubed, y=T_squared, hue=names, s=100) plt.plot(r_cubed, T_squared, 'k--', alpha=0.6) # Line for visual confirmation plt.xlabel(\"r\u00b3 (AU\u00b3)\") plt.ylabel(\"T\u00b2 (years\u00b2)\") plt.title(\"Verification of Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True) plt.legend(title=\"Planet\") plt.tight_layout() plt.show() import ace_tools as tools; tools.display_dataframe_to_user(name=\"Planetary Orbital Data\", dataframe=df) Visit: Colab Planetary Orbital Data (AU & Years) Planet Orbital Radius \\( r \\) (AU) Orbital Period \\( T \\) (years) \\( r^3 \\) (AU\u00b3) \\( T^2 \\) (years\u00b2) Mercury 0.390 0.240846 0.059319 0.058007 Venus 0.723 0.615 0.377933 0.378225 Earth 1.000 1.000 1.000000 1.000000 Mars 1.524 1.881 3.539606 3.538161 Animation of a Circular Orbit import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of the Earth (kg) r = 3.84e8 # Radius of the orbit (Moon-Earth distance, m) omega = np.sqrt(G * M / r**3) # Angular velocity (rad/s) # Time settings T = 2 * np.pi / omega # Orbital period (s) t_vals = np.linspace(0, T, 500) # Time points # Orbital coordinates x_vals = r * np.cos(omega * t_vals) y_vals = r * np.sin(omega * t_vals) # Plot setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2*r, 1.2*r) ax.set_ylim(-1.2*r, 1.2*r) ax.set_aspect('equal') ax.set_title('Circular Orbit') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') # Static Earth ax.plot(0, 0, 'yo', markersize=12, label='Earth') # Satellite dot and path satellite, = ax.plot([], [], 'ro', label='Satellite') path, = ax.plot([], [], 'r--', alpha=0.5) def init(): satellite.set_data([], []) path.set_data([], []) return satellite, path def update(frame): # Ensure x and y are lists or 1-dimensional arrays x = [x_vals[frame]] # or x = np.array([x_vals[frame]]) y = [y_vals[frame]] # or y = np.array([y_vals[frame]]) satellite.set_data(x, y) path.set_data(x_vals[:frame+1], y_vals[:frame+1]) return satellite, path ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True, interval=20) # Display in Jupyter/Colab HTML(ani.to_jshtml()) Visit: Colab Extensions to Elliptical Orbits Kepler\u2019s Third Law generalizes to elliptical orbits: \\[T^2 \\propto a^3\\] Where \\(a\\) is the semi-major axis . This law still holds but requires integration over elliptical motion, using: Vis-viva equation: \\(v^2 = G M \\left( \\frac{2}{r} - \\frac{1}{a} \\right)\\) Orbital energy methods Numerical integration for eccentric orbits Astronomical Implications Calculate planetary masses Estimate satellite altitudes Study exoplanet orbits Design satellite constellations (e.g., Starlink) Measure black hole masses via stellar motion Aspect Description Law \\(T^2 \\propto r^3\\) for circular orbits Derived From Newton\u2019s Law + differential equations Verification Simulations, plots of \\(T^2\\) vs \\(r^3\\) Used For Planetary systems, satellites, exoplanets Animation Visualized stable orbit with Python Kepler\u2019s Law Applied to the Solar System Planets: Mercury, Venus, Earth, Mars Planet Orbital Radius (10\u2078 km) Period (days) Mercury 57.9 87.97 Venus 108.2 224.70 Earth 149.6 365.25 Mars 227.9 687.00 Calculating Mass of Earth (Using the Moon) \\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) G = 6.67430e-11 r_earth_moon = 3.844e8 T_moon = 27.32 * 86400 M_earth = 4 * np.pi**2 * r_earth_moon**3 / (G * T_moon**2) print(f\"Mass of Earth \u2248 {M_earth:.2e} kg\") Output: \\(5.97 \\times 10^{24} \\, \\text{kg}\\) (correct) Calculating Mass of the Sun (Using Earth's Orbit) \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) \\(T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) r_earth_sun = 1.496e11 T_earth = 365.25 * 86400 M_sun = 4 * np.pi**2 * r_earth_sun**3 / (G * T_earth**2) print(f\"Mass of Sun \u2248 {M_sun:.2e} kg\") Output: \\(1.99 \\times 10^{30} \\, \\text{kg}\\) (correct) Orbit Animation from matplotlib.animation import FuncAnimation from IPython.display import HTML # Time setup t_vals = np.linspace(0, 2 * np.pi, 500) x_vals = r_earth_sun * np.cos(t_vals) y_vals = r_earth_sun * np.sin(t_vals) fig, ax = plt.subplots(figsize=(6,6)) ax.set_xlim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_ylim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') earth, = ax.plot([], [], 'ro') sun = ax.plot(0, 0, 'yo', markersize=12) def init(): earth.set_data([], []) return earth, def update(i): earth.set_data(x_vals[i], y_vals[i]) return earth, ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True) HTML(ani.to_jshtml()) Visit: Colab Concept Value Kepler's Law \\(T^2 \\propto r^3\\) Derived from Newton's Gravity + Centripetal Motion T\u00b2 vs r\u00b3 Plot Straight line confirmed Mass of Earth \\(\\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) Mass of Sun \\(\\approx 1.99 \\times 10^{30} \\, \\text{kg}\\) Planets Used Mercury, Venus, Earth, Mars Python All steps simulated and visualized","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The elegant relationship between the square of the orbital period (T) and the cube of the orbital radius (r) for circular orbits, known as Kepler\u2019s Third Law , reveals deep insights into gravitational interactions. This project aims to derive this law starting from Newtonian mechanics and differential equations, explore its real-world implications, and validate it through simulations and animations. Kepler\u2019s Third Law reveals a fundamental relationship in orbital mechanics: \\[T^2 \\propto r^3\\] This law connects the period of revolution \\(T\\) of a planet (or satellite) with the radius \\(r\\) of its circular orbit. It's a powerful tool used in celestial mechanics, satellite design, and calculating masses of celestial bodies.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-derivation-using-newtonian-mechanics","text":"","title":"Theoretical Derivation using Newtonian Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-gravitational-force","text":"Newton\u2019s Law of Gravitation \\[F_g = \\frac{G M m}{r^2}\\]","title":"Step 1: Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-centripetal-force-for-circular-orbits","text":"\\[F_c = \\frac{m v^2}{r}\\]","title":"Step 2: Centripetal Force for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-3-equating-forces","text":"\\[\\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\]","title":"Step 3: Equating Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-4-express-orbital-period","text":"\\[T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2}\\] Substitute \\(v^2\\) : \\[T^2 = \\frac{4\\pi^2 r^2}{\\frac{G M}{r}} = \\frac{4\\pi^2 r^3}{G M}\\] Final Form: \\[T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\Rightarrow T^2 \\propto r^3\\]","title":"Step 4: Express Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-analysis-via-differential-equations","text":"","title":"Theoretical Analysis via Differential Equations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-universal-gravitation","text":"Gravitational force between two bodies of mass \\(M\\) (e.g., Earth) and \\(m\\) (e.g., satellite) is: \\[F = \\frac{G M m}{r^2}\\]","title":"Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#circular-motion-requirement","text":"For an object to stay in circular orbit, this gravitational force must equal the centripetal force: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\]","title":"Circular Motion Requirement"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-using-differential-equations","text":"The radial acceleration for a mass \\(m\\) in circular motion is: \\[\\vec{a} = \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M}{r^2} \\hat{r}\\] If the motion is constrained to a circular orbit, the position vector is: \\[\\vec{r}(t) = r (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j})\\] Differentiating twice gives: \\[\\frac{d^2 \\vec{r}}{dt^2} = -r \\omega^2 (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j}) = -\\omega^2 \\vec{r}\\] From Newton\u2019s second law: \\[m \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M m}{r^2} \\hat{r} \\Rightarrow -m \\omega^2 \\vec{r} = -\\frac{G M m}{r^2} \\hat{r}\\] Solving: \\[\\omega^2 = \\frac{G M}{r^3} \\Rightarrow T^2 = \\left( \\frac{2\\pi}{\\omega} \\right)^2 = \\frac{4\\pi^2 r^3}{G M}\\] This is Kepler\u2019s Third Law for circular orbits.","title":"Derivation Using Differential Equations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#moons-orbit-around-earth","text":"Radius: \\(r \\approx 3.84 \\times 10^8\\) m Period: \\(T \\approx 27.3\\) days Verify Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\)","title":"Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-in-the-solar-system","text":"Planet Orbital Radius (AU) Period (years) Mercury 0.39 0.24 Earth 1.00 1.00 Jupiter 5.20 11.86 \\[\\frac{T^2}{r^3} \\approx \\text{constant}\\] import matplotlib.pyplot as plt import numpy as np # Sample data (replace with your actual data) radius = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.54]) # AU period = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Calculate T^2 and R^3 T_squared = period**2 R_cubed = radius**3 # Create the plot plt.figure(figsize=(8, 6)) plt.scatter(R_cubed, T_squared, label='Data Points') # Create the scatter plot # Add a best fit line (linear regression) coefficients = np.polyfit(R_cubed, T_squared, 1) polynomial = np.poly1d(coefficients) R_cubed_fit = np.linspace(min(R_cubed), max(R_cubed), 100) plt.plot(R_cubed_fit, polynomial(R_cubed_fit), color='red', label='Best Fit Line') # Add labels and title plt.xlabel(r'$R^3$ (AU$^3$)') plt.ylabel(r'$T^2$ (years$^2$)') plt.title('Orbital Period vs. Radius (Kepler\\'s Third Law)') plt.grid(True) # Add grid for better readability plt.legend() # Calculate and print the slope slope = coefficients[0] print(f\"Slope of the best-fit line: {slope:.2f}\") # Add text annotation showing the slope on the plot. plt.annotate(f\"Slope: {slope:.2f}\", xy=(0.65 * max(R_cubed), 0.85 * max(T_squared)), fontsize=12) # Show the plot plt.show() Visit: Colab","title":"Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#verifying-keplers-law","text":"!pip install ace_tools # Install the required 'ace_tools' module import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns # Orbital data for planets (radius in AU, period in years) planets = { \"Mercury\": {\"r_AU\": 0.39, \"T_years\": 0.240846}, \"Venus\": {\"r_AU\": 0.723, \"T_years\": 0.615}, \"Earth\": {\"r_AU\": 1.000, \"T_years\": 1.000}, \"Mars\": {\"r_AU\": 1.524, \"T_years\": 1.881} } # Convert to arrays names = list(planets.keys()) r_AU = np.array([planets[p][\"r_AU\"] for p in names]) T_years = np.array([planets[p][\"T_years\"] for p in names]) # Calculate T^2 and r^3 T_squared = T_years**2 r_cubed = r_AU**3 # Create a DataFrame for visualization df = pd.DataFrame({ \"Planet\": names, \"r (AU)\": r_AU, \"T (years)\": T_years, \"r^3 (AU^3)\": r_cubed, \"T^2 (years^2)\": T_squared }) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 6)) sns.scatterplot(x=r_cubed, y=T_squared, hue=names, s=100) plt.plot(r_cubed, T_squared, 'k--', alpha=0.6) # Line for visual confirmation plt.xlabel(\"r\u00b3 (AU\u00b3)\") plt.ylabel(\"T\u00b2 (years\u00b2)\") plt.title(\"Verification of Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True) plt.legend(title=\"Planet\") plt.tight_layout() plt.show() import ace_tools as tools; tools.display_dataframe_to_user(name=\"Planetary Orbital Data\", dataframe=df) Visit: Colab","title":"Verifying Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planetary-orbital-data-au-years","text":"Planet Orbital Radius \\( r \\) (AU) Orbital Period \\( T \\) (years) \\( r^3 \\) (AU\u00b3) \\( T^2 \\) (years\u00b2) Mercury 0.390 0.240846 0.059319 0.058007 Venus 0.723 0.615 0.377933 0.378225 Earth 1.000 1.000 1.000000 1.000000 Mars 1.524 1.881 3.539606 3.538161","title":"Planetary Orbital Data (AU &amp; Years)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#animation-of-a-circular-orbit","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of the Earth (kg) r = 3.84e8 # Radius of the orbit (Moon-Earth distance, m) omega = np.sqrt(G * M / r**3) # Angular velocity (rad/s) # Time settings T = 2 * np.pi / omega # Orbital period (s) t_vals = np.linspace(0, T, 500) # Time points # Orbital coordinates x_vals = r * np.cos(omega * t_vals) y_vals = r * np.sin(omega * t_vals) # Plot setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2*r, 1.2*r) ax.set_ylim(-1.2*r, 1.2*r) ax.set_aspect('equal') ax.set_title('Circular Orbit') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') # Static Earth ax.plot(0, 0, 'yo', markersize=12, label='Earth') # Satellite dot and path satellite, = ax.plot([], [], 'ro', label='Satellite') path, = ax.plot([], [], 'r--', alpha=0.5) def init(): satellite.set_data([], []) path.set_data([], []) return satellite, path def update(frame): # Ensure x and y are lists or 1-dimensional arrays x = [x_vals[frame]] # or x = np.array([x_vals[frame]]) y = [y_vals[frame]] # or y = np.array([y_vals[frame]]) satellite.set_data(x, y) path.set_data(x_vals[:frame+1], y_vals[:frame+1]) return satellite, path ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True, interval=20) # Display in Jupyter/Colab HTML(ani.to_jshtml())","title":"Animation of a Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visitcolab","text":"","title":"Visit:Colab"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extensions-to-elliptical-orbits","text":"Kepler\u2019s Third Law generalizes to elliptical orbits: \\[T^2 \\propto a^3\\] Where \\(a\\) is the semi-major axis . This law still holds but requires integration over elliptical motion, using: Vis-viva equation: \\(v^2 = G M \\left( \\frac{2}{r} - \\frac{1}{a} \\right)\\) Orbital energy methods Numerical integration for eccentric orbits","title":"Extensions to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-implications","text":"Calculate planetary masses Estimate satellite altitudes Study exoplanet orbits Design satellite constellations (e.g., Starlink) Measure black hole masses via stellar motion Aspect Description Law \\(T^2 \\propto r^3\\) for circular orbits Derived From Newton\u2019s Law + differential equations Verification Simulations, plots of \\(T^2\\) vs \\(r^3\\) Used For Planetary systems, satellites, exoplanets Animation Visualized stable orbit with Python","title":"Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-law-applied-to-the-solar-system","text":"","title":"Kepler\u2019s Law Applied to the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-mercury-venus-earth-mars","text":"Planet Orbital Radius (10\u2078 km) Period (days) Mercury 57.9 87.97 Venus 108.2 224.70 Earth 149.6 365.25 Mars 227.9 687.00","title":"Planets: Mercury, Venus, Earth, Mars"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-mass-of-earth-using-the-moon","text":"\\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) G = 6.67430e-11 r_earth_moon = 3.844e8 T_moon = 27.32 * 86400 M_earth = 4 * np.pi**2 * r_earth_moon**3 / (G * T_moon**2) print(f\"Mass of Earth \u2248 {M_earth:.2e} kg\") Output: \\(5.97 \\times 10^{24} \\, \\text{kg}\\) (correct)","title":"Calculating Mass of Earth (Using the Moon)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-mass-of-the-sun-using-earths-orbit","text":"\\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) \\(T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) r_earth_sun = 1.496e11 T_earth = 365.25 * 86400 M_sun = 4 * np.pi**2 * r_earth_sun**3 / (G * T_earth**2) print(f\"Mass of Sun \u2248 {M_sun:.2e} kg\") Output: \\(1.99 \\times 10^{30} \\, \\text{kg}\\) (correct)","title":"Calculating Mass of the Sun (Using Earth's Orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbit-animation","text":"from matplotlib.animation import FuncAnimation from IPython.display import HTML # Time setup t_vals = np.linspace(0, 2 * np.pi, 500) x_vals = r_earth_sun * np.cos(t_vals) y_vals = r_earth_sun * np.sin(t_vals) fig, ax = plt.subplots(figsize=(6,6)) ax.set_xlim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_ylim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') earth, = ax.plot([], [], 'ro') sun = ax.plot(0, 0, 'yo', markersize=12) def init(): earth.set_data([], []) return earth, def update(i): earth.set_data(x_vals[i], y_vals[i]) return earth, ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True) HTML(ani.to_jshtml()) Visit: Colab Concept Value Kepler's Law \\(T^2 \\propto r^3\\) Derived from Newton's Gravity + Centripetal Motion T\u00b2 vs r\u00b3 Plot Straight line confirmed Mass of Earth \\(\\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) Mass of Sun \\(\\approx 1.99 \\times 10^{30} \\, \\text{kg}\\) Planets Used Mercury, Venus, Earth, Mars Python All steps simulated and visualized","title":"Orbit Animation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Introduction In celestial mechanics and spaceflight engineering, understanding the conditions required to move between gravitational domains is essential. From launching satellites into Earth orbit to sending interstellar probes like Voyager , space missions must overcome gravitational boundaries defined by the cosmic velocities . These velocities represent thresholds in orbital mechanics, each marking a different kind of escape: First Cosmic Velocity : Required to enter stable circular orbit. Second Cosmic Velocity : Required to completely escape a planet\u2019s gravity. Third Cosmic Velocity : Required to escape both a planet\u2019s and its star's gravity, reaching interstellar space. 2. Theoretical Foundation 2.1 First Cosmic Velocity \u2013 Orbital Velocity Concept : The speed to stay in low circular orbit, counteracting gravity with centripetal acceleration. Derivation : \\( \\(F_{\\text{gravity}} = \\frac{GMm}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{mv^2}{r}\\) \\) Equating the two: \\( \\(\\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{r}}\\) \\) Intuition : Go too slow, you fall back. Go too fast, you escape. 2.2 Second Cosmic Velocity \u2013 Escape Velocity Concept : Minimum speed to reach infinity with zero kinetic energy remaining. Energy Approach : \\( \\(E = K + U = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\geq 0 \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{r}}\\) \\) Notice : \\(v_2 = \\sqrt{2} \\cdot v_1\\) . It takes ~41% more speed than orbiting to escape. 2.3 Third Cosmic Velocity \u2013 Solar System Escape Concept : Speed to escape both the planet and the Sun from the planet\u2019s orbit. \\[v_3 = \\sqrt{v_2^2 + v_{\\text{orbit,Sun}}^2} = \\sqrt{2 \\frac{GM_p}{r} + \\frac{GM_\\odot}{R_{\\text{orbit}}}}\\] Where: - \\(M_\\odot\\) : mass of the Sun. - \\(R_{\\text{orbit}}\\) : orbital radius of the planet. Key Point : You\u2019re fighting two gravity wells : the planet and the star. 3. Simulation & Code 3.1 Python Code: Velocity Calculations & Visualization import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_sun = 1.989e30 # [Mass (kg), Radius (m), Orbital Radius from Sun (m)] bodies = { \"Earth\": [5.972e24, 6.371e6, 1.496e11], \"Moon\": [7.342e22, 1.737e6, 1.5e11 + 3.844e8], \"Mars\": [6.417e23, 3.389e6, 2.279e11], \"Jupiter\": [1.898e27, 6.9911e7, 7.785e11] } def v1(M, R): return np.sqrt(G * M / R) def v2(M, R): return np.sqrt(2 * G * M / R) def v3(M, R, R_orbit): return np.sqrt(v2(M, R)**2 + (G * M_sun / R_orbit)) v1s, v2s, v3s, names = [], [], [], [] for name, (M, R, R_orbit) in bodies.items(): names.append(name) v1s.append(v1(M, R)) v2s.append(v2(M, R)) v3s.append(v3(M, R, R_orbit)) # Plot x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(10, 6)) plt.bar(x - width, np.array(v1s)/1000, width, label='1st Cosmic Velocity') plt.bar(x, np.array(v2s)/1000, width, label='2nd Cosmic Velocity') plt.bar(x + width, np.array(v3s)/1000, width, label='3rd Cosmic Velocity') plt.xticks(x, names) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities of Celestial Bodies\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visit: Colab 3.2 Numerical Results Table Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) Mass Ratio (to Earth) Earth 7.91 11.19 ~42.1 1.00 Moon 1.68 2.38 ~41.4 0.012 Mars 3.56 5.03 ~40.3 0.107 Jupiter 42.1 59.5 ~75.4 317.8 3.3 Escape Velocity vs. Planetary Radius and Mass import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # Ranges of radius and mass radii = np.linspace(1e6, 1e8, 100) # from 1,000 km to 100,000 km masses = [1e22, 1e24, 1e26, 1e28] # various planet masses plt.figure(figsize=(10, 6)) for M in masses: v_esc = np.sqrt(2 * G * M / radii) plt.plot(radii / 1e6, v_esc / 1e3, label=f'M = {M:.0e} kg') plt.xlabel('Radius (10\u2076 m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs. Radius for Different Masses') plt.legend() plt.grid(True) plt.tight_layout() plt.show() Visit: Colab 3.4 Cosmic Velocity Ratios (v2/v1 and v3/v2) # Calculate ratios v1_arr = np.array(v1s) v2_arr = np.array(v2s) v3_arr = np.array(v3s) ratios_21 = v2_arr / v1_arr ratios_32 = v3_arr / v2_arr x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(10, 5)) plt.bar(x - width/2, ratios_21, width, label='v\u2082 / v\u2081') plt.bar(x + width/2, ratios_32, width, label='v\u2083 / v\u2082') plt.xticks(x, names) plt.ylabel(\"Velocity Ratio\") plt.title(\"Cosmic Velocity Ratios Across Celestial Bodies\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visit: Colab 3.5 3D-Like Plot of Velocities vs Mass and Radius from mpl_toolkits.mplot3d import Axes3D # Meshgrid of radii and masses r_vals = np.linspace(1e6, 1e8, 100) m_vals = np.linspace(1e22, 1e28, 100) R, M = np.meshgrid(r_vals, m_vals) V_escape = np.sqrt(2 * G * M / R) fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(R/1e6, M/1e24, V_escape/1e3, cmap='viridis') ax.set_xlabel('Radius (10\u2076 m)') ax.set_ylabel('Mass (10\u00b2\u2074 kg)') ax.set_zlabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity vs. Mass and Radius') plt.tight_layout() plt.show() Visit: Colab 3.6 Animated Escape Velocity vs. Radius for Increasing Mass # First, import animation tools import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 radii = np.linspace(1e6, 1e8, 300) # Radii from 1000 km to 100,000 km # Mass range (frame-wise) mass_vals = np.linspace(1e22, 1e28, 100) # From small asteroid to gas giant fig, ax = plt.subplots(figsize=(8, 6)) line, = ax.plot([], [], lw=2) text = ax.text(0.05, 0.9, '', transform=ax.transAxes) ax.set_xlim(radii[0]/1e6, radii[-1]/1e6) ax.set_ylim(0, 100) ax.set_xlabel('Radius (10\u2076 m)') ax.set_ylabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity vs Radius for Varying Mass') ax.grid() def init(): line.set_data([], []) text.set_text('') return line, text def update(frame): M = mass_vals[frame] v_esc = np.sqrt(2 * G * M / radii) / 1000 # Convert to km/s line.set_data(radii / 1e6, v_esc) text.set_text(f'Mass = {M:.1e} kg') return line, text ani = FuncAnimation(fig, update, frames=len(mass_vals), init_func=init, blit=True) plt.close() HTML(ani.to_jshtml()) Visit: Colab 4. Engineering and Mission Design Use Cases by Velocity Cosmic Velocity Use Case 1st Satellite launch (LEO, MEO) 2nd Planetary missions (Mars, Moon) 3rd Interstellar travel (Voyager, Pioneer) Design Considerations Fuel Efficiency : Most fuel is spent reaching low orbit. Timing and gravity assists help achieve 2nd/3rd velocities. Gravity Assists : Used by Voyager , Cassini , and New Horizons to incrementally achieve solar system escape. 5. Future Exploration and Cosmic Challenges Voyager 1 is the only human object beyond the heliopause (~17 km/s). Interstellar Missions like Breakthrough Starshot aim to reach 0.1c using laser propulsion. Cosmic Horizons : Interstellar escape velocities will eventually require non-chemical propulsion\u2014solar sails, nuclear, or antimatter-based tech. 6. Conclusion Cosmic velocities define the very boundary between planetary, interplanetary, and interstellar travel. These are not abstract ideas but the core calculations used to plan every space mission. From basic orbits to escaping the solar system, this knowledge: Guides launch protocols. Optimizes fuel usage. Enables human dreams of interstellar travel. Space exploration begins not with a rocket launch, but with understanding these fundamental speeds.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction","text":"In celestial mechanics and spaceflight engineering, understanding the conditions required to move between gravitational domains is essential. From launching satellites into Earth orbit to sending interstellar probes like Voyager , space missions must overcome gravitational boundaries defined by the cosmic velocities . These velocities represent thresholds in orbital mechanics, each marking a different kind of escape: First Cosmic Velocity : Required to enter stable circular orbit. Second Cosmic Velocity : Required to completely escape a planet\u2019s gravity. Third Cosmic Velocity : Required to escape both a planet\u2019s and its star's gravity, reaching interstellar space.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-first-cosmic-velocity-orbital-velocity","text":"Concept : The speed to stay in low circular orbit, counteracting gravity with centripetal acceleration. Derivation : \\( \\(F_{\\text{gravity}} = \\frac{GMm}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{mv^2}{r}\\) \\) Equating the two: \\( \\(\\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{r}}\\) \\) Intuition : Go too slow, you fall back. Go too fast, you escape.","title":"2.1 First Cosmic Velocity \u2013 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-second-cosmic-velocity-escape-velocity","text":"Concept : Minimum speed to reach infinity with zero kinetic energy remaining. Energy Approach : \\( \\(E = K + U = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\geq 0 \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{r}}\\) \\) Notice : \\(v_2 = \\sqrt{2} \\cdot v_1\\) . It takes ~41% more speed than orbiting to escape.","title":"2.2 Second Cosmic Velocity \u2013 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity-solar-system-escape","text":"Concept : Speed to escape both the planet and the Sun from the planet\u2019s orbit. \\[v_3 = \\sqrt{v_2^2 + v_{\\text{orbit,Sun}}^2} = \\sqrt{2 \\frac{GM_p}{r} + \\frac{GM_\\odot}{R_{\\text{orbit}}}}\\] Where: - \\(M_\\odot\\) : mass of the Sun. - \\(R_{\\text{orbit}}\\) : orbital radius of the planet. Key Point : You\u2019re fighting two gravity wells : the planet and the star.","title":"2.3 Third Cosmic Velocity \u2013 Solar System Escape"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-simulation-code","text":"","title":"3. Simulation &amp; Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-python-code-velocity-calculations-visualization","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_sun = 1.989e30 # [Mass (kg), Radius (m), Orbital Radius from Sun (m)] bodies = { \"Earth\": [5.972e24, 6.371e6, 1.496e11], \"Moon\": [7.342e22, 1.737e6, 1.5e11 + 3.844e8], \"Mars\": [6.417e23, 3.389e6, 2.279e11], \"Jupiter\": [1.898e27, 6.9911e7, 7.785e11] } def v1(M, R): return np.sqrt(G * M / R) def v2(M, R): return np.sqrt(2 * G * M / R) def v3(M, R, R_orbit): return np.sqrt(v2(M, R)**2 + (G * M_sun / R_orbit)) v1s, v2s, v3s, names = [], [], [], [] for name, (M, R, R_orbit) in bodies.items(): names.append(name) v1s.append(v1(M, R)) v2s.append(v2(M, R)) v3s.append(v3(M, R, R_orbit)) # Plot x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(10, 6)) plt.bar(x - width, np.array(v1s)/1000, width, label='1st Cosmic Velocity') plt.bar(x, np.array(v2s)/1000, width, label='2nd Cosmic Velocity') plt.bar(x + width, np.array(v3s)/1000, width, label='3rd Cosmic Velocity') plt.xticks(x, names) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities of Celestial Bodies\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visit: Colab","title":"3.1 Python Code: Velocity Calculations &amp; Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-numerical-results-table","text":"Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) Mass Ratio (to Earth) Earth 7.91 11.19 ~42.1 1.00 Moon 1.68 2.38 ~41.4 0.012 Mars 3.56 5.03 ~40.3 0.107 Jupiter 42.1 59.5 ~75.4 317.8","title":"3.2 Numerical Results Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#33-escape-velocity-vs-planetary-radius-and-mass","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # Ranges of radius and mass radii = np.linspace(1e6, 1e8, 100) # from 1,000 km to 100,000 km masses = [1e22, 1e24, 1e26, 1e28] # various planet masses plt.figure(figsize=(10, 6)) for M in masses: v_esc = np.sqrt(2 * G * M / radii) plt.plot(radii / 1e6, v_esc / 1e3, label=f'M = {M:.0e} kg') plt.xlabel('Radius (10\u2076 m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs. Radius for Different Masses') plt.legend() plt.grid(True) plt.tight_layout() plt.show() Visit: Colab","title":"3.3 Escape Velocity vs. Planetary Radius and Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#34-cosmic-velocity-ratios-v2v1-and-v3v2","text":"# Calculate ratios v1_arr = np.array(v1s) v2_arr = np.array(v2s) v3_arr = np.array(v3s) ratios_21 = v2_arr / v1_arr ratios_32 = v3_arr / v2_arr x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(10, 5)) plt.bar(x - width/2, ratios_21, width, label='v\u2082 / v\u2081') plt.bar(x + width/2, ratios_32, width, label='v\u2083 / v\u2082') plt.xticks(x, names) plt.ylabel(\"Velocity Ratio\") plt.title(\"Cosmic Velocity Ratios Across Celestial Bodies\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visit: Colab","title":"3.4 Cosmic Velocity Ratios (v2/v1 and v3/v2)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#35-3d-like-plot-of-velocities-vs-mass-and-radius","text":"from mpl_toolkits.mplot3d import Axes3D # Meshgrid of radii and masses r_vals = np.linspace(1e6, 1e8, 100) m_vals = np.linspace(1e22, 1e28, 100) R, M = np.meshgrid(r_vals, m_vals) V_escape = np.sqrt(2 * G * M / R) fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(R/1e6, M/1e24, V_escape/1e3, cmap='viridis') ax.set_xlabel('Radius (10\u2076 m)') ax.set_ylabel('Mass (10\u00b2\u2074 kg)') ax.set_zlabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity vs. Mass and Radius') plt.tight_layout() plt.show() Visit: Colab","title":"3.5 3D-Like Plot of Velocities vs Mass and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_2/#36-animated-escape-velocity-vs-radius-for-increasing-mass","text":"# First, import animation tools import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 radii = np.linspace(1e6, 1e8, 300) # Radii from 1000 km to 100,000 km # Mass range (frame-wise) mass_vals = np.linspace(1e22, 1e28, 100) # From small asteroid to gas giant fig, ax = plt.subplots(figsize=(8, 6)) line, = ax.plot([], [], lw=2) text = ax.text(0.05, 0.9, '', transform=ax.transAxes) ax.set_xlim(radii[0]/1e6, radii[-1]/1e6) ax.set_ylim(0, 100) ax.set_xlabel('Radius (10\u2076 m)') ax.set_ylabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity vs Radius for Varying Mass') ax.grid() def init(): line.set_data([], []) text.set_text('') return line, text def update(frame): M = mass_vals[frame] v_esc = np.sqrt(2 * G * M / radii) / 1000 # Convert to km/s line.set_data(radii / 1e6, v_esc) text.set_text(f'Mass = {M:.1e} kg') return line, text ani = FuncAnimation(fig, update, frames=len(mass_vals), init_func=init, blit=True) plt.close() HTML(ani.to_jshtml()) Visit: Colab","title":"3.6 Animated Escape Velocity vs. Radius for Increasing Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-engineering-and-mission-design","text":"","title":"4. Engineering and Mission Design"},{"location":"1%20Physics/2%20Gravity/Problem_2/#use-cases-by-velocity","text":"Cosmic Velocity Use Case 1st Satellite launch (LEO, MEO) 2nd Planetary missions (Mars, Moon) 3rd Interstellar travel (Voyager, Pioneer)","title":"Use Cases by Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#design-considerations","text":"Fuel Efficiency : Most fuel is spent reaching low orbit. Timing and gravity assists help achieve 2nd/3rd velocities. Gravity Assists : Used by Voyager , Cassini , and New Horizons to incrementally achieve solar system escape.","title":"Design Considerations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-future-exploration-and-cosmic-challenges","text":"Voyager 1 is the only human object beyond the heliopause (~17 km/s). Interstellar Missions like Breakthrough Starshot aim to reach 0.1c using laser propulsion. Cosmic Horizons : Interstellar escape velocities will eventually require non-chemical propulsion\u2014solar sails, nuclear, or antimatter-based tech.","title":"5. Future Exploration and Cosmic Challenges"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-conclusion","text":"Cosmic velocities define the very boundary between planetary, interplanetary, and interstellar travel. These are not abstract ideas but the core calculations used to plan every space mission. From basic orbits to escaping the solar system, this knowledge: Guides launch protocols. Optimizes fuel usage. Enables human dreams of interstellar travel. Space exploration begins not with a rocket launch, but with understanding these fundamental speeds.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Introduction When a payload is released from a moving rocket near Earth, its motion depends on initial velocity, altitude, and gravitational forces . Understanding these trajectories is essential for orbital insertion, reentry planning, and satellite deployment . The possible paths include: - Elliptical orbits (if velocity is below escape velocity). - Parabolic trajectories (if velocity equals escape velocity). - Hyperbolic escape paths (if velocity exceeds escape velocity). - Suborbital trajectories (if reentry occurs). 2. Theoretical Background 2.1 Governing Equations Using Newton\u2019s Second Law and Universal Gravitation, the equation of motion for a payload influenced only by Earth\u2019s gravity is: \\[\\mathbf{F} = m \\mathbf{a} = -\\frac{G M m}{r^2} \\hat{r}\\] which leads to the gravitational acceleration : \\[\\mathbf{a} = -\\frac{G M}{r^2} \\hat{r}\\] where: - \\(G = 6.674 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2 (gravitational constant). - \\(M = 5.972 \\times 10^{24}\\) kg (mass of Earth). - \\(r\\) is the payload\u2019s radial distance from Earth\u2019s center. For different initial velocities \\(( v_0)\\) at release altitude \\(r_0\\) : - If \\(v_0 < v_1\\) (orbital velocity): Suborbital reentry . - If \\(v_0 = v_1\\) : Circular orbit . - If \\(v_1 < v_0 < v_2\\) (escape velocity): Elliptical orbit . - If \\(v_0 = v_2\\) : Parabolic escape . - If \\(v_0 > v_2\\) : Hyperbolic escape . 3. Numerical Simulation We simulate a payload's trajectory using Runge-Kutta methods to solve the equation of motion in two dimensions. Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from scipy.constants import G # Define Earth parameters M_earth = 5.972e24 # kg R_earth = 6.371e6 # meters # Define the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, vy, ax, ay] # Initial conditions: Release altitude and velocity altitude = 400e3 # 400 km above Earth r0 = R_earth + altitude v0_values = [6.8e3, 7.9e3, 11.2e3] # Below, at, and above orbital velocity (m/s) # Time span t_span = (0, 5000) t_eval = np.linspace(*t_span, 1000) # Simulate and plot different cases plt.figure(figsize=(7, 7)) for v0 in v0_values: initial_state = [r0, 0, 0, v0] # (x0, y0, vx0, vy0) sol = solve_ivp(equations, t_span, initial_state, t_eval=t_eval, method='RK45') plt.plot(sol.y[0], sol.y[1], label=f'v0 = {v0 / 1e3:.1f} km/s') # Plot Earth theta = np.linspace(0, 2*np.pi, 100) plt.plot(R_earth * np.cos(theta), R_earth * np.sin(theta), 'k', label='Earth') plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Payload Trajectories Near Earth\") plt.legend() plt.grid() plt.axis('equal') plt.show() Colab 4. Results and Discussion Suborbital (e.g., \\( v_0 = 6.8 \\) km/s) : The payload follows a curved trajectory but falls back to Earth. Orbital Insertion (e.g., \\( v_0 = 7.9 \\) km/s) : The payload enters a stable circular orbit. Escape Trajectory (e.g., \\( v_0 = 11.2 \\) km/s) : The payload follows a hyperbolic path, escaping Earth's gravity. Real-World Applications Satellite Deployment : Space agencies use precise velocity control to achieve stable orbits. Reentry Planning : Spacecraft must control velocity for safe reentry (e.g., ISS, capsules). Interplanetary Travel : Higher velocity payloads can escape Earth and travel to Mars or beyond. 5. Conclusion This report analyzed the trajectories of a freely released payload using theoretical equations and numerical simulations . The results confirm how initial velocity dictates whether a payload reenters, orbits, or escapes . This understanding is fundamental in space mission planning, satellite deployment, and interplanetary travel . Future extensions could include atmospheric drag effects, three-body interactions, or maneuvering thruster effects .","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction","text":"When a payload is released from a moving rocket near Earth, its motion depends on initial velocity, altitude, and gravitational forces . Understanding these trajectories is essential for orbital insertion, reentry planning, and satellite deployment . The possible paths include: - Elliptical orbits (if velocity is below escape velocity). - Parabolic trajectories (if velocity equals escape velocity). - Hyperbolic escape paths (if velocity exceeds escape velocity). - Suborbital trajectories (if reentry occurs).","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-theoretical-background","text":"","title":"2. Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#21-governing-equations","text":"Using Newton\u2019s Second Law and Universal Gravitation, the equation of motion for a payload influenced only by Earth\u2019s gravity is: \\[\\mathbf{F} = m \\mathbf{a} = -\\frac{G M m}{r^2} \\hat{r}\\] which leads to the gravitational acceleration : \\[\\mathbf{a} = -\\frac{G M}{r^2} \\hat{r}\\] where: - \\(G = 6.674 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2 (gravitational constant). - \\(M = 5.972 \\times 10^{24}\\) kg (mass of Earth). - \\(r\\) is the payload\u2019s radial distance from Earth\u2019s center. For different initial velocities \\(( v_0)\\) at release altitude \\(r_0\\) : - If \\(v_0 < v_1\\) (orbital velocity): Suborbital reentry . - If \\(v_0 = v_1\\) : Circular orbit . - If \\(v_1 < v_0 < v_2\\) (escape velocity): Elliptical orbit . - If \\(v_0 = v_2\\) : Parabolic escape . - If \\(v_0 > v_2\\) : Hyperbolic escape .","title":"2.1 Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-numerical-simulation","text":"We simulate a payload's trajectory using Runge-Kutta methods to solve the equation of motion in two dimensions.","title":"3. Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from scipy.constants import G # Define Earth parameters M_earth = 5.972e24 # kg R_earth = 6.371e6 # meters # Define the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, vy, ax, ay] # Initial conditions: Release altitude and velocity altitude = 400e3 # 400 km above Earth r0 = R_earth + altitude v0_values = [6.8e3, 7.9e3, 11.2e3] # Below, at, and above orbital velocity (m/s) # Time span t_span = (0, 5000) t_eval = np.linspace(*t_span, 1000) # Simulate and plot different cases plt.figure(figsize=(7, 7)) for v0 in v0_values: initial_state = [r0, 0, 0, v0] # (x0, y0, vx0, vy0) sol = solve_ivp(equations, t_span, initial_state, t_eval=t_eval, method='RK45') plt.plot(sol.y[0], sol.y[1], label=f'v0 = {v0 / 1e3:.1f} km/s') # Plot Earth theta = np.linspace(0, 2*np.pi, 100) plt.plot(R_earth * np.cos(theta), R_earth * np.sin(theta), 'k', label='Earth') plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Payload Trajectories Near Earth\") plt.legend() plt.grid() plt.axis('equal') plt.show() Colab","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-results-and-discussion","text":"Suborbital (e.g., \\( v_0 = 6.8 \\) km/s) : The payload follows a curved trajectory but falls back to Earth. Orbital Insertion (e.g., \\( v_0 = 7.9 \\) km/s) : The payload enters a stable circular orbit. Escape Trajectory (e.g., \\( v_0 = 11.2 \\) km/s) : The payload follows a hyperbolic path, escaping Earth's gravity.","title":"4. Results and Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Satellite Deployment : Space agencies use precise velocity control to achieve stable orbits. Reentry Planning : Spacecraft must control velocity for safe reentry (e.g., ISS, capsules). Interplanetary Travel : Higher velocity payloads can escape Earth and travel to Mars or beyond.","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-conclusion","text":"This report analyzed the trajectories of a freely released payload using theoretical equations and numerical simulations . The results confirm how initial velocity dictates whether a payload reenters, orbits, or escapes . This understanding is fundamental in space mission planning, satellite deployment, and interplanetary travel . Future extensions could include atmospheric drag effects, three-body interactions, or maneuvering thruster effects .","title":"5. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Introduction Wave interference occurs when multiple waves overlap, leading to constructive (amplification) and destructive (cancellation) interference. On a water surface , circular waves from different sources create complex interference patterns , which are influenced by the number, position, and phase of sources . This study investigates interference patterns from multiple point sources arranged in regular polygons . Understanding such patterns has applications in acoustics, optics, and fluid dynamics . 2. Theoretical Background 2.1 Wave Equation for a Point Source A circular wave from a point source at position \\(\\mathbf{r_i}\\) is given by: \\[\\psi_i(\\mathbf{r}, t) = A \\cos(k r_i - \\omega t + \\phi_0)\\] where: - \\(\\psi_i(\\mathbf{r}, t)\\) is the displacement at point \\(\\mathbf{r}\\) and time \\(t\\) . - \\(A\\) is the amplitude . - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number . - \\(\\omega = 2\\pi f\\) is the angular frequency . - \\(r_i = |\\mathbf{r} - \\mathbf{r_i}|\\) is the distance from the source. - \\(\\phi_0\\) is the initial phase . 2.2 Superposition of Multiple Waves If there are \\(N\\) wave sources at positions \\(\\mathbf{r_i}\\) , the total displacement is: \\[\\Psi(\\mathbf{r}, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi_0)\\] The interference pattern results from this sum. 2.3 Regular Polygon Source Arrangement We place sources at the vertices of a regular polygon (e.g., triangle, square, pentagon ) with center at the origin. Each vertex has coordinates: \\[\\mathbf{r_i} = R (\\cos \\theta_i, \\sin \\theta_i)\\] where \\(\\theta_i = \\frac{2\\pi i}{N}\\) , for \\(i = 0, 1, ..., N-1\\) . 3. Computational Simulation Python Implementation We simulate wave interference for sources placed at the vertices of a regular polygon using NumPy and Matplotlib . import numpy as np import matplotlib.pyplot as plt # Define wave parameters A = 1 # Amplitude lambda_wave = 1 # Wavelength k = 2 * np.pi / lambda_wave # Wave number omega = 2 * np.pi # Angular frequency N = 5 # Number of sources (Regular pentagon) R = 5 # Distance of sources from origin grid_size = 200 # Resolution # Define spatial grid x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y) # Define source positions (vertices of polygon) angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R * np.cos(angle), R * np.sin(angle)) for angle in angles] # Compute wave superposition wave_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) wave_sum += A * np.cos(k * r) # Plot the interference pattern plt.figure(figsize=(7, 7)) plt.imshow(wave_sum, extent=[-10, 10, -10, 10], cmap=\"RdBu\", origin=\"lower\") plt.colorbar(label=\"Wave Displacement\") plt.scatter(*zip(*sources), color=\"black\", marker=\"o\", label=\"Wave Sources\") plt.title(\"Interference Pattern for a Regular Pentagon\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.show() Colab 4. Results and Discussion Constructive Interference occurs where waves reinforce each other, creating bright regions. Destructive Interference occurs where waves cancel, forming dark regions. The polygon shape affects the pattern , leading to symmetric and repeating interference zones . Different Polygon Cases Polygon Interference Behavior Triangle (N=3) Large interference zones, simple symmetry. Square (N=4) More complex interference fringes. Pentagon (N=5) Higher symmetry, intricate wave interactions. Real-World Applications Optics: Interference of light waves in holography and diffraction gratings . Acoustics: Sound wave interference in concert halls and speaker systems . Fluid Dynamics: Wave interactions in oceans and engineering . 5. Conclusion This report investigated wave interference on a water surface for multiple sources arranged in regular polygons . The numerical simulation confirmed that the source arrangement significantly influences interference patterns . Future work could explore nonlinear effects, wave damping, and 3D wave interactions .","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-introduction","text":"Wave interference occurs when multiple waves overlap, leading to constructive (amplification) and destructive (cancellation) interference. On a water surface , circular waves from different sources create complex interference patterns , which are influenced by the number, position, and phase of sources . This study investigates interference patterns from multiple point sources arranged in regular polygons . Understanding such patterns has applications in acoustics, optics, and fluid dynamics .","title":"1. Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-theoretical-background","text":"","title":"2. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#21-wave-equation-for-a-point-source","text":"A circular wave from a point source at position \\(\\mathbf{r_i}\\) is given by: \\[\\psi_i(\\mathbf{r}, t) = A \\cos(k r_i - \\omega t + \\phi_0)\\] where: - \\(\\psi_i(\\mathbf{r}, t)\\) is the displacement at point \\(\\mathbf{r}\\) and time \\(t\\) . - \\(A\\) is the amplitude . - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number . - \\(\\omega = 2\\pi f\\) is the angular frequency . - \\(r_i = |\\mathbf{r} - \\mathbf{r_i}|\\) is the distance from the source. - \\(\\phi_0\\) is the initial phase .","title":"2.1 Wave Equation for a Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#22-superposition-of-multiple-waves","text":"If there are \\(N\\) wave sources at positions \\(\\mathbf{r_i}\\) , the total displacement is: \\[\\Psi(\\mathbf{r}, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi_0)\\] The interference pattern results from this sum.","title":"2.2 Superposition of Multiple Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#23-regular-polygon-source-arrangement","text":"We place sources at the vertices of a regular polygon (e.g., triangle, square, pentagon ) with center at the origin. Each vertex has coordinates: \\[\\mathbf{r_i} = R (\\cos \\theta_i, \\sin \\theta_i)\\] where \\(\\theta_i = \\frac{2\\pi i}{N}\\) , for \\(i = 0, 1, ..., N-1\\) .","title":"2.3 Regular Polygon Source Arrangement"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-computational-simulation","text":"","title":"3. Computational Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-implementation","text":"We simulate wave interference for sources placed at the vertices of a regular polygon using NumPy and Matplotlib . import numpy as np import matplotlib.pyplot as plt # Define wave parameters A = 1 # Amplitude lambda_wave = 1 # Wavelength k = 2 * np.pi / lambda_wave # Wave number omega = 2 * np.pi # Angular frequency N = 5 # Number of sources (Regular pentagon) R = 5 # Distance of sources from origin grid_size = 200 # Resolution # Define spatial grid x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y) # Define source positions (vertices of polygon) angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R * np.cos(angle), R * np.sin(angle)) for angle in angles] # Compute wave superposition wave_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) wave_sum += A * np.cos(k * r) # Plot the interference pattern plt.figure(figsize=(7, 7)) plt.imshow(wave_sum, extent=[-10, 10, -10, 10], cmap=\"RdBu\", origin=\"lower\") plt.colorbar(label=\"Wave Displacement\") plt.scatter(*zip(*sources), color=\"black\", marker=\"o\", label=\"Wave Sources\") plt.title(\"Interference Pattern for a Regular Pentagon\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.show() Colab","title":"Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-results-and-discussion","text":"Constructive Interference occurs where waves reinforce each other, creating bright regions. Destructive Interference occurs where waves cancel, forming dark regions. The polygon shape affects the pattern , leading to symmetric and repeating interference zones .","title":"4. Results and Discussion"},{"location":"1%20Physics/3%20Waves/Problem_1/#different-polygon-cases","text":"Polygon Interference Behavior Triangle (N=3) Large interference zones, simple symmetry. Square (N=4) More complex interference fringes. Pentagon (N=5) Higher symmetry, intricate wave interactions.","title":"Different Polygon Cases"},{"location":"1%20Physics/3%20Waves/Problem_1/#real-world-applications","text":"Optics: Interference of light waves in holography and diffraction gratings . Acoustics: Sound wave interference in concert halls and speaker systems . Fluid Dynamics: Wave interactions in oceans and engineering .","title":"Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-conclusion","text":"This report investigated wave interference on a water surface for multiple sources arranged in regular polygons . The numerical simulation confirmed that the source arrangement significantly influences interference patterns . Future work could explore nonlinear effects, wave damping, and 3D wave interactions .","title":"5. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation: The Lorentz force, described by the equation F = q(E + v \u00d7 B) , governs the motion of charged particles in the presence of electric (E) and magnetic (B) fields. This force is fundamental in numerous areas of physics, including particle accelerators, mass spectrometers, and plasma confinement. By simulating particle motion under the influence of these fields, we can visualize the complex trajectories and gain insight into practical applications in areas such as cyclotrons and magnetic confinement systems. 1. Exploration of Applications: The Lorentz force is central to systems where charged particles interact with electromagnetic fields. Key applications include: - Particle Accelerators: In cyclotrons or synchrotrons, charged particles are accelerated by electric fields and guided by magnetic fields. - Mass Spectrometers: Charged particles are deflected by magnetic fields, allowing scientists to measure their mass-to-charge ratio. - Plasma Confinement: Magnetic fields are used to confine plasma in devices like Tokamaks for nuclear fusion research. Electric fields \\((E)\\) affect particles by accelerating them in the direction of the field, while magnetic fields \\((B)\\) exert a force perpendicular to both the velocity of the particle and the magnetic field, causing circular or spiral motion. The combination of these fields controls the particle's motion in advanced technologies. 2. Simulating Particle Motion: To simulate the motion of a charged particle, we solve the Lorentz force equation using numerical methods. We will simulate the particle\u2019s motion under different field configurations: - Uniform Magnetic Field: The particle moves in a circular or helical trajectory depending on the initial velocity components. - Combined Electric and Magnetic Fields: The electric and magnetic forces combine to produce more complex trajectories, like drift or spiral motion. - Crossed Electric and Magnetic Fields: A specific case where the electric and magnetic fields are perpendicular to each other, leading to interesting particle behavior. 3. Parameter Exploration: In the simulation, we will vary the following parameters: - Field Strengths (E, B): The intensity of the electric and magnetic fields. - Initial Particle Velocity (v): The starting velocity of the particle, including both magnitude and direction. - Charge and Mass of the Particle (q, m): The properties of the particle will influence the strength of the Lorentz force. These parameters will be varied to observe their impact on the trajectory of the particle. 4. Visualization: We will generate 2D and 3D visualizations of the particle's motion. Key phenomena to be highlighted include: - Larmor Radius: The radius of the circular path the particle follows in a uniform magnetic field. - Drift Velocity: The velocity of the particle when both electric and magnetic fields are present. Python Code Implementation: We use numerical integration (Euler or Runge-Kutta method) to solve the equation of motion for the charged particle. Below is an implementation using Python with the NumPy and Matplotlib libraries for calculations and visualizations. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle in Coulombs m = 9.11e-31 # Mass of the particle in kg E = np.array([0, 0, 0]) # Electric field (zero for this example) B = np.array([0, 0, 1]) # Magnetic field along the z-axis v_initial = np.array([1e6, 0, 0]) # Initial velocity of the particle (m/s) # Time setup t_max = 1e-6 # Maximum time dt = 1e-9 # Time step steps = int(t_max / dt) # Number of steps # Arrays to store position and velocity positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) # Initial conditions positions[0] = np.array([0, 0, 0]) velocities[0] = v_initial # Simulation loop for i in range(1, steps): # Lorentz force F = q(E + v x B) v = velocities[i-1] F = q * (E + np.cross(v, B)) # Update velocity and position using Euler's method velocities[i] = v + F * dt / m positions[i] = positions[i-1] + velocities[i] * dt # Plot the results in 3D fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) # Label axes and show the plot ax.set_xlabel('X position (m)') ax.set_ylabel('Y position (m)') ax.set_zlabel('Z position (m)') ax.set_title('Particle Trajectory under Lorentz Force') plt.show() Colab 5. Discussion: This simulation provides a clear visualization of how a charged particle behaves under different field configurations. The motion can be circular, helical, or drift depending on the presence of the electric and magnetic fields. In a uniform magnetic field , the particle traces a circular path with a radius determined by the Larmor radius , which is given by the equation: \\( \\(r_L = \\frac{mv_{\\perp}}{qB}\\) \\) where \\(v_{\\perp}\\) is the component of the velocity perpendicular to the magnetic field. In combined fields , the particle may exhibit complex motion such as drift velocity, where the electric field exerts a force in the direction of the field, while the magnetic field causes perpendicular motion. This simulation mimics the behavior observed in real-world devices like cyclotrons and mass spectrometers , where charged particles are manipulated by magnetic fields for acceleration and detection. 6. Suggestions for Future Extensions: Non-Uniform Fields: Extend the simulation to include non-uniform electric and magnetic fields (e.g., magnetic gradients in a magnetic trap). Relativistic Effects: For very high velocities, include relativistic corrections to the particle\u2019s mass and velocity. Particle Collisions: Add more complexity by simulating interactions between multiple particles. Conclusion: Simulating the Lorentz force provides valuable insights into the motion of charged particles in electromagnetic fields, essential for understanding the behavior of systems like particle accelerators and mass spectrometers. The results from this simulation offer a practical and visual understanding of how particles are controlled in these systems, with further potential to extend this model to more complex scenarios.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, described by the equation F = q(E + v \u00d7 B) , governs the motion of charged particles in the presence of electric (E) and magnetic (B) fields. This force is fundamental in numerous areas of physics, including particle accelerators, mass spectrometers, and plasma confinement. By simulating particle motion under the influence of these fields, we can visualize the complex trajectories and gain insight into practical applications in areas such as cyclotrons and magnetic confinement systems.","title":"Motivation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"The Lorentz force is central to systems where charged particles interact with electromagnetic fields. Key applications include: - Particle Accelerators: In cyclotrons or synchrotrons, charged particles are accelerated by electric fields and guided by magnetic fields. - Mass Spectrometers: Charged particles are deflected by magnetic fields, allowing scientists to measure their mass-to-charge ratio. - Plasma Confinement: Magnetic fields are used to confine plasma in devices like Tokamaks for nuclear fusion research. Electric fields \\((E)\\) affect particles by accelerating them in the direction of the field, while magnetic fields \\((B)\\) exert a force perpendicular to both the velocity of the particle and the magnetic field, causing circular or spiral motion. The combination of these fields controls the particle's motion in advanced technologies.","title":"1. Exploration of Applications:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"To simulate the motion of a charged particle, we solve the Lorentz force equation using numerical methods. We will simulate the particle\u2019s motion under different field configurations: - Uniform Magnetic Field: The particle moves in a circular or helical trajectory depending on the initial velocity components. - Combined Electric and Magnetic Fields: The electric and magnetic forces combine to produce more complex trajectories, like drift or spiral motion. - Crossed Electric and Magnetic Fields: A specific case where the electric and magnetic fields are perpendicular to each other, leading to interesting particle behavior.","title":"2. Simulating Particle Motion:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"In the simulation, we will vary the following parameters: - Field Strengths (E, B): The intensity of the electric and magnetic fields. - Initial Particle Velocity (v): The starting velocity of the particle, including both magnitude and direction. - Charge and Mass of the Particle (q, m): The properties of the particle will influence the strength of the Lorentz force. These parameters will be varied to observe their impact on the trajectory of the particle.","title":"3. Parameter Exploration:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"We will generate 2D and 3D visualizations of the particle's motion. Key phenomena to be highlighted include: - Larmor Radius: The radius of the circular path the particle follows in a uniform magnetic field. - Drift Velocity: The velocity of the particle when both electric and magnetic fields are present.","title":"4. Visualization:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-implementation","text":"We use numerical integration (Euler or Runge-Kutta method) to solve the equation of motion for the charged particle. Below is an implementation using Python with the NumPy and Matplotlib libraries for calculations and visualizations. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle in Coulombs m = 9.11e-31 # Mass of the particle in kg E = np.array([0, 0, 0]) # Electric field (zero for this example) B = np.array([0, 0, 1]) # Magnetic field along the z-axis v_initial = np.array([1e6, 0, 0]) # Initial velocity of the particle (m/s) # Time setup t_max = 1e-6 # Maximum time dt = 1e-9 # Time step steps = int(t_max / dt) # Number of steps # Arrays to store position and velocity positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) # Initial conditions positions[0] = np.array([0, 0, 0]) velocities[0] = v_initial # Simulation loop for i in range(1, steps): # Lorentz force F = q(E + v x B) v = velocities[i-1] F = q * (E + np.cross(v, B)) # Update velocity and position using Euler's method velocities[i] = v + F * dt / m positions[i] = positions[i-1] + velocities[i] * dt # Plot the results in 3D fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) # Label axes and show the plot ax.set_xlabel('X position (m)') ax.set_ylabel('Y position (m)') ax.set_zlabel('Z position (m)') ax.set_title('Particle Trajectory under Lorentz Force') plt.show() Colab","title":"Python Code Implementation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-discussion","text":"This simulation provides a clear visualization of how a charged particle behaves under different field configurations. The motion can be circular, helical, or drift depending on the presence of the electric and magnetic fields. In a uniform magnetic field , the particle traces a circular path with a radius determined by the Larmor radius , which is given by the equation: \\( \\(r_L = \\frac{mv_{\\perp}}{qB}\\) \\) where \\(v_{\\perp}\\) is the component of the velocity perpendicular to the magnetic field. In combined fields , the particle may exhibit complex motion such as drift velocity, where the electric field exerts a force in the direction of the field, while the magnetic field causes perpendicular motion. This simulation mimics the behavior observed in real-world devices like cyclotrons and mass spectrometers , where charged particles are manipulated by magnetic fields for acceleration and detection.","title":"5. Discussion:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-suggestions-for-future-extensions","text":"Non-Uniform Fields: Extend the simulation to include non-uniform electric and magnetic fields (e.g., magnetic gradients in a magnetic trap). Relativistic Effects: For very high velocities, include relativistic corrections to the particle\u2019s mass and velocity. Particle Collisions: Add more complexity by simulating interactions between multiple particles.","title":"6. Suggestions for Future Extensions:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"Simulating the Lorentz force provides valuable insights into the motion of charged particles in electromagnetic fields, essential for understanding the behavior of systems like particle accelerators and mass spectrometers. The results from this simulation offer a practical and visual understanding of how particles are controlled in these systems, with further potential to extend this model to more complex scenarios.","title":"Conclusion:"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory 1. Introduction Calculating equivalent resistance in electrical circuits is essential for analyzing and designing efficient electrical systems. While traditional methods involve applying series and parallel resistance rules, these approaches become cumbersome for circuits with many components. Using graph theory , we can simplify circuit analysis by representing the circuit as a graph where nodes represent junctions and edges represent resistors. This report explores an algorithmic approach to calculating equivalent resistance using graph theory. Specifically, we will describe a graph-based algorithm that simplifies circuits systematically, reducing even the most intricate networks into manageable components. The method's versatility makes it an ideal solution for circuit simulation, optimization, and automated analysis. 2. Problem Statement In this task, we aim to develop an algorithm that calculates the equivalent resistance for arbitrary circuits by representing them as graphs . The algorithm should: Identify series and parallel connections of resistors. Iteratively reduce the graph until a single equivalent resistance is obtained. Handle complex circuits with nested series and parallel combinations . 3. Algorithm Description We will describe an algorithm that uses graph theory to calculate the equivalent resistance of a circuit. The graph representation has: Nodes : Junctions or points in the circuit. Edges : Resistors connecting the nodes. Step 1: Represent the Circuit as a Graph We start by representing the circuit as a graph \\(G(V, E)\\) , where: - \\(V\\) is the set of nodes (junctions). - \\(E\\) is the set of edges (resistors with resistance \\(R\\) ). Step 2: Detect Series and Parallel Connections Series Connection : Two resistors \\(R_1\\) and \\(R_2\\) are in series if they are connected directly end-to-end. The total resistance \\(R_{\\text{total}} = R_1 + R_2\\) . Parallel Connection : Two resistors \\(R_1\\) and \\(R_2\\) are in parallel if they are connected across the same two nodes. The total resistance \\(R_{\\text{total}} = \\frac{1}{\\left(\\frac{1}{R_1} + \\frac{1}{R_2}\\right)}\\) . Step 3: Iteratively Simplify the Graph Using depth-first search (DFS) or breadth-first search (BFS) , we: 1. Identify series and parallel connections. 2. Replace the simplified sections with a single equivalent resistance. 3. Repeat the process until only one edge remains, which represents the equivalent resistance. Step 4: Handle Nested Configurations The algorithm can handle nested series and parallel configurations by applying the series and parallel reduction rules recursively. 4. Python Implementation We will implement the algorithm using the Python NetworkX library, which simplifies graph manipulation. import networkx as nx def series_reduction(R1, R2): \"\"\"Calculates the equivalent resistance for resistors in series.\"\"\" return R1 + R2 def parallel_reduction(R1, R2): \"\"\"Calculates the equivalent resistance for resistors in parallel.\"\"\" return 1 / (1/R1 + 1/R2) def find_series_parallel(graph): \"\"\"Identifies series and parallel connections in the graph.\"\"\" series_connections = [] parallel_connections = [] # Check each pair of nodes for series and parallel connections for edge1 in graph.edges: for edge2 in graph.edges: if edge1 != edge2: # Check if edge1 and edge2 are in series or parallel # Add logic for series/parallel detection pass return series_connections, parallel_connections def simplify_graph(graph): \"\"\"Simplifies the graph by reducing series and parallel resistors.\"\"\" series_connections, parallel_connections = find_series_parallel(graph) for edge1, edge2 in series_connections: R1 = graph[edge1[0]][edge1[1]]['resistance'] R2 = graph[edge2[0]][edge2[1]]['resistance'] new_R = series_reduction(R1, R2) # Replace the two resistors with the equivalent one graph.remove_edge(edge1[0], edge1[1]) graph.remove_edge(edge2[0], edge2[1]) # Add a new edge with resistance 'new_R' for edge1, edge2 in parallel_connections: R1 = graph[edge1[0]][edge1[1]]['resistance'] R2 = graph[edge2[0]][edge2[1]]['resistance'] new_R = parallel_reduction(R1, R2) # Replace the two resistors with the equivalent one graph.remove_edge(edge1[0], edge1[1]) graph.remove_edge(edge2[0], edge2[1]) # Add a new edge with resistance 'new_R' return graph def calculate_equivalent_resistance(graph): \"\"\"Calculates the total equivalent resistance of the circuit.\"\"\" while len(graph.edges) > 1: graph = simplify_graph(graph) # Final equivalent resistance return graph[graph.nodes[0]][graph.nodes[1]]['resistance'] # Example graph with resistors G = nx.Graph() G.add_edge(0, 1, resistance=5) G.add_edge(1, 2, resistance=10) print(f\"Equivalent resistance: {calculate_equivalent_resistance(G)} Ohms\") 5. Analysis and Efficiency Time Complexity The algorithm's complexity depends on the number of edges and nodes in the graph. Each simplification step involves searching for series and parallel connections, which is generally linear in terms of the number of edges. In the worst case, this could require \\(O(E^2)\\) for graph traversal. Space Complexity Space complexity is \\(O(V + E)\\) , where \\(V\\) is the number of vertices and \\(E\\) is the number of edges in the graph. Possible Improvements Optimized Search : Use more efficient graph traversal techniques to identify series and parallel connections faster. Parallel Processing : For larger graphs, parallelizing the search and simplification process could lead to performance improvements. 6. Conclusion This approach uses graph theory to simplify and calculate the equivalent resistance of electrical circuits. The algorithm iteratively reduces complex networks by identifying series and parallel resistor connections. This method is computationally efficient and extends well to more complex circuits with nested combinations. Future improvements could focus on optimizing the search process and enhancing scalability for larger circuits.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-introduction","text":"Calculating equivalent resistance in electrical circuits is essential for analyzing and designing efficient electrical systems. While traditional methods involve applying series and parallel resistance rules, these approaches become cumbersome for circuits with many components. Using graph theory , we can simplify circuit analysis by representing the circuit as a graph where nodes represent junctions and edges represent resistors. This report explores an algorithmic approach to calculating equivalent resistance using graph theory. Specifically, we will describe a graph-based algorithm that simplifies circuits systematically, reducing even the most intricate networks into manageable components. The method's versatility makes it an ideal solution for circuit simulation, optimization, and automated analysis.","title":"1. Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-problem-statement","text":"In this task, we aim to develop an algorithm that calculates the equivalent resistance for arbitrary circuits by representing them as graphs . The algorithm should: Identify series and parallel connections of resistors. Iteratively reduce the graph until a single equivalent resistance is obtained. Handle complex circuits with nested series and parallel combinations .","title":"2. Problem Statement"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-algorithm-description","text":"We will describe an algorithm that uses graph theory to calculate the equivalent resistance of a circuit. The graph representation has: Nodes : Junctions or points in the circuit. Edges : Resistors connecting the nodes.","title":"3. Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-represent-the-circuit-as-a-graph","text":"We start by representing the circuit as a graph \\(G(V, E)\\) , where: - \\(V\\) is the set of nodes (junctions). - \\(E\\) is the set of edges (resistors with resistance \\(R\\) ).","title":"Step 1: Represent the Circuit as a Graph"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-detect-series-and-parallel-connections","text":"Series Connection : Two resistors \\(R_1\\) and \\(R_2\\) are in series if they are connected directly end-to-end. The total resistance \\(R_{\\text{total}} = R_1 + R_2\\) . Parallel Connection : Two resistors \\(R_1\\) and \\(R_2\\) are in parallel if they are connected across the same two nodes. The total resistance \\(R_{\\text{total}} = \\frac{1}{\\left(\\frac{1}{R_1} + \\frac{1}{R_2}\\right)}\\) .","title":"Step 2: Detect Series and Parallel Connections"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-3-iteratively-simplify-the-graph","text":"Using depth-first search (DFS) or breadth-first search (BFS) , we: 1. Identify series and parallel connections. 2. Replace the simplified sections with a single equivalent resistance. 3. Repeat the process until only one edge remains, which represents the equivalent resistance.","title":"Step 3: Iteratively Simplify the Graph"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-4-handle-nested-configurations","text":"","title":"Step 4: Handle Nested Configurations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#the-algorithm-can-handle-nested-series-and-parallel-configurations-by-applying-the-series-and-parallel-reduction-rules-recursively","text":"","title":"The algorithm can handle nested series and parallel configurations by applying the series and parallel reduction rules recursively."},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-python-implementation","text":"We will implement the algorithm using the Python NetworkX library, which simplifies graph manipulation. import networkx as nx def series_reduction(R1, R2): \"\"\"Calculates the equivalent resistance for resistors in series.\"\"\" return R1 + R2 def parallel_reduction(R1, R2): \"\"\"Calculates the equivalent resistance for resistors in parallel.\"\"\" return 1 / (1/R1 + 1/R2) def find_series_parallel(graph): \"\"\"Identifies series and parallel connections in the graph.\"\"\" series_connections = [] parallel_connections = [] # Check each pair of nodes for series and parallel connections for edge1 in graph.edges: for edge2 in graph.edges: if edge1 != edge2: # Check if edge1 and edge2 are in series or parallel # Add logic for series/parallel detection pass return series_connections, parallel_connections def simplify_graph(graph): \"\"\"Simplifies the graph by reducing series and parallel resistors.\"\"\" series_connections, parallel_connections = find_series_parallel(graph) for edge1, edge2 in series_connections: R1 = graph[edge1[0]][edge1[1]]['resistance'] R2 = graph[edge2[0]][edge2[1]]['resistance'] new_R = series_reduction(R1, R2) # Replace the two resistors with the equivalent one graph.remove_edge(edge1[0], edge1[1]) graph.remove_edge(edge2[0], edge2[1]) # Add a new edge with resistance 'new_R' for edge1, edge2 in parallel_connections: R1 = graph[edge1[0]][edge1[1]]['resistance'] R2 = graph[edge2[0]][edge2[1]]['resistance'] new_R = parallel_reduction(R1, R2) # Replace the two resistors with the equivalent one graph.remove_edge(edge1[0], edge1[1]) graph.remove_edge(edge2[0], edge2[1]) # Add a new edge with resistance 'new_R' return graph def calculate_equivalent_resistance(graph): \"\"\"Calculates the total equivalent resistance of the circuit.\"\"\" while len(graph.edges) > 1: graph = simplify_graph(graph) # Final equivalent resistance return graph[graph.nodes[0]][graph.nodes[1]]['resistance'] # Example graph with resistors G = nx.Graph() G.add_edge(0, 1, resistance=5) G.add_edge(1, 2, resistance=10) print(f\"Equivalent resistance: {calculate_equivalent_resistance(G)} Ohms\")","title":"4. Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-analysis-and-efficiency","text":"","title":"5. Analysis and Efficiency"},{"location":"1%20Physics/5%20Circuits/Problem_1/#time-complexity","text":"The algorithm's complexity depends on the number of edges and nodes in the graph. Each simplification step involves searching for series and parallel connections, which is generally linear in terms of the number of edges. In the worst case, this could require \\(O(E^2)\\) for graph traversal.","title":"Time Complexity"},{"location":"1%20Physics/5%20Circuits/Problem_1/#space-complexity","text":"Space complexity is \\(O(V + E)\\) , where \\(V\\) is the number of vertices and \\(E\\) is the number of edges in the graph.","title":"Space Complexity"},{"location":"1%20Physics/5%20Circuits/Problem_1/#possible-improvements","text":"Optimized Search : Use more efficient graph traversal techniques to identify series and parallel connections faster. Parallel Processing : For larger graphs, parallelizing the search and simplification process could lead to performance improvements.","title":"Possible Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-conclusion","text":"This approach uses graph theory to simplify and calculate the equivalent resistance of electrical circuits. The algorithm iteratively reduces complex networks by identifying series and parallel resistor connections. This method is computationally efficient and extends well to more complex circuits with nested combinations. Future improvements could focus on optimizing the search process and enhancing scalability for larger circuits.","title":"6. Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}